# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Dict, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization


class Action(msrest.serialization.Model):
    """Action descriptor.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AlertingAction, LogToMetricAction.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. Specifies the action. Supported values - AlertingAction,
     LogToMetricAction.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.AlertingAction': 'AlertingAction', 'Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.LogToMetricAction': 'LogToMetricAction'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Action, self).__init__(**kwargs)
        self.odata_type = None


class ActionGroupList(msrest.serialization.Model):
    """A list of action groups.

    :param value: The list of action groups.
    :type value: list[~monitor_client.models.ActionGroupResource]
    :param next_link: Provides the link to retrieve the next set of elements.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ActionGroupResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ActionGroupResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(ActionGroupList, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ActionGroupPatchBody(msrest.serialization.Model):
    """An action group object for the body of patch operations.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param enabled: Indicates whether this action group is enabled. If an action group is not
     enabled, then none of its actions will be activated.
    :type enabled: bool
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        enabled: Optional[bool] = True,
        **kwargs
    ):
        super(ActionGroupPatchBody, self).__init__(**kwargs)
        self.tags = tags
        self.enabled = enabled


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class ActionGroupResource(Resource):
    """An action group resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param group_short_name: The short name of the action group. This will be used in SMS messages.
    :type group_short_name: str
    :param enabled: Indicates whether this action group is enabled. If an action group is not
     enabled, then none of its receivers will receive communications.
    :type enabled: bool
    :param email_receivers: The list of email receivers that are part of this action group.
    :type email_receivers: list[~monitor_client.models.EmailReceiver]
    :param sms_receivers: The list of SMS receivers that are part of this action group.
    :type sms_receivers: list[~monitor_client.models.SmsReceiver]
    :param webhook_receivers: The list of webhook receivers that are part of this action group.
    :type webhook_receivers: list[~monitor_client.models.WebhookReceiver]
    :param itsm_receivers: The list of ITSM receivers that are part of this action group.
    :type itsm_receivers: list[~monitor_client.models.ItsmReceiver]
    :param azure_app_push_receivers: The list of AzureAppPush receivers that are part of this
     action group.
    :type azure_app_push_receivers: list[~monitor_client.models.AzureAppPushReceiver]
    :param automation_runbook_receivers: The list of AutomationRunbook receivers that are part of
     this action group.
    :type automation_runbook_receivers: list[~monitor_client.models.AutomationRunbookReceiver]
    :param voice_receivers: The list of voice receivers that are part of this action group.
    :type voice_receivers: list[~monitor_client.models.VoiceReceiver]
    :param logic_app_receivers: The list of logic app receivers that are part of this action group.
    :type logic_app_receivers: list[~monitor_client.models.LogicAppReceiver]
    :param azure_function_receivers: The list of azure function receivers that are part of this
     action group.
    :type azure_function_receivers: list[~monitor_client.models.AzureFunctionReceiver]
    :param arm_role_receivers: The list of ARM role receivers that are part of this action group.
     Roles are Azure RBAC roles and only built-in roles are supported.
    :type arm_role_receivers: list[~monitor_client.models.ArmRoleReceiver]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'group_short_name': {'max_length': 12, 'min_length': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'group_short_name': {'key': 'properties.groupShortName', 'type': 'str'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'email_receivers': {'key': 'properties.emailReceivers', 'type': '[EmailReceiver]'},
        'sms_receivers': {'key': 'properties.smsReceivers', 'type': '[SmsReceiver]'},
        'webhook_receivers': {'key': 'properties.webhookReceivers', 'type': '[WebhookReceiver]'},
        'itsm_receivers': {'key': 'properties.itsmReceivers', 'type': '[ItsmReceiver]'},
        'azure_app_push_receivers': {'key': 'properties.azureAppPushReceivers', 'type': '[AzureAppPushReceiver]'},
        'automation_runbook_receivers': {'key': 'properties.automationRunbookReceivers', 'type': '[AutomationRunbookReceiver]'},
        'voice_receivers': {'key': 'properties.voiceReceivers', 'type': '[VoiceReceiver]'},
        'logic_app_receivers': {'key': 'properties.logicAppReceivers', 'type': '[LogicAppReceiver]'},
        'azure_function_receivers': {'key': 'properties.azureFunctionReceivers', 'type': '[AzureFunctionReceiver]'},
        'arm_role_receivers': {'key': 'properties.armRoleReceivers', 'type': '[ArmRoleReceiver]'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        group_short_name: Optional[str] = None,
        enabled: Optional[bool] = True,
        email_receivers: Optional[List["EmailReceiver"]] = None,
        sms_receivers: Optional[List["SmsReceiver"]] = None,
        webhook_receivers: Optional[List["WebhookReceiver"]] = None,
        itsm_receivers: Optional[List["ItsmReceiver"]] = None,
        azure_app_push_receivers: Optional[List["AzureAppPushReceiver"]] = None,
        automation_runbook_receivers: Optional[List["AutomationRunbookReceiver"]] = None,
        voice_receivers: Optional[List["VoiceReceiver"]] = None,
        logic_app_receivers: Optional[List["LogicAppReceiver"]] = None,
        azure_function_receivers: Optional[List["AzureFunctionReceiver"]] = None,
        arm_role_receivers: Optional[List["ArmRoleReceiver"]] = None,
        **kwargs
    ):
        super(ActionGroupResource, self).__init__(location=location, tags=tags, **kwargs)
        self.group_short_name = group_short_name
        self.enabled = enabled
        self.email_receivers = email_receivers
        self.sms_receivers = sms_receivers
        self.webhook_receivers = webhook_receivers
        self.itsm_receivers = itsm_receivers
        self.azure_app_push_receivers = azure_app_push_receivers
        self.automation_runbook_receivers = automation_runbook_receivers
        self.voice_receivers = voice_receivers
        self.logic_app_receivers = logic_app_receivers
        self.azure_function_receivers = azure_function_receivers
        self.arm_role_receivers = arm_role_receivers


class ActivityLogAlertActionGroup(msrest.serialization.Model):
    """A pointer to an Azure Action Group.

    All required parameters must be populated in order to send to Azure.

    :param action_group_id: Required. The resourceId of the action group. This cannot be null or
     empty.
    :type action_group_id: str
    :param webhook_properties: the dictionary of custom properties to include with the post
     operation. These data are appended to the webhook payload.
    :type webhook_properties: dict[str, str]
    """

    _validation = {
        'action_group_id': {'required': True},
    }

    _attribute_map = {
        'action_group_id': {'key': 'actionGroupId', 'type': 'str'},
        'webhook_properties': {'key': 'webhookProperties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        action_group_id: str,
        webhook_properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ActivityLogAlertActionGroup, self).__init__(**kwargs)
        self.action_group_id = action_group_id
        self.webhook_properties = webhook_properties


class ActivityLogAlertActionList(msrest.serialization.Model):
    """A list of activity log alert actions.

    :param action_groups: The list of activity log alerts.
    :type action_groups: list[~monitor_client.models.ActivityLogAlertActionGroup]
    """

    _attribute_map = {
        'action_groups': {'key': 'actionGroups', 'type': '[ActivityLogAlertActionGroup]'},
    }

    def __init__(
        self,
        *,
        action_groups: Optional[List["ActivityLogAlertActionGroup"]] = None,
        **kwargs
    ):
        super(ActivityLogAlertActionList, self).__init__(**kwargs)
        self.action_groups = action_groups


class ActivityLogAlertAllOfCondition(msrest.serialization.Model):
    """An Activity Log alert condition that is met when all its member conditions are met.

    All required parameters must be populated in order to send to Azure.

    :param all_of: Required. The list of activity log alert conditions.
    :type all_of: list[~monitor_client.models.ActivityLogAlertLeafCondition]
    """

    _validation = {
        'all_of': {'required': True},
    }

    _attribute_map = {
        'all_of': {'key': 'allOf', 'type': '[ActivityLogAlertLeafCondition]'},
    }

    def __init__(
        self,
        *,
        all_of: List["ActivityLogAlertLeafCondition"],
        **kwargs
    ):
        super(ActivityLogAlertAllOfCondition, self).__init__(**kwargs)
        self.all_of = all_of


class ActivityLogAlertLeafCondition(msrest.serialization.Model):
    """An Activity Log alert condition that is met by comparing an activity log field and value.

    All required parameters must be populated in order to send to Azure.

    :param field: Required. The name of the field that this condition will examine. The possible
     values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level',
     'operationName', 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or
     anything beginning with 'properties.'.
    :type field: str
    :param equals: Required. The field value will be compared to this value (case-insensitive) to
     determine if the condition is met.
    :type equals: str
    """

    _validation = {
        'field': {'required': True},
        'equals': {'required': True},
    }

    _attribute_map = {
        'field': {'key': 'field', 'type': 'str'},
        'equals': {'key': 'equals', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        field: str,
        equals: str,
        **kwargs
    ):
        super(ActivityLogAlertLeafCondition, self).__init__(**kwargs)
        self.field = field
        self.equals = equals


class ActivityLogAlertList(msrest.serialization.Model):
    """A list of activity log alerts.

    :param value: The list of activity log alerts.
    :type value: list[~monitor_client.models.ActivityLogAlertResource]
    :param next_link: Provides the link to retrieve the next set of elements.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ActivityLogAlertResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ActivityLogAlertResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(ActivityLogAlertList, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ActivityLogAlertPatchBody(msrest.serialization.Model):
    """An activity log alert object for the body of patch operations.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param enabled: Indicates whether this activity log alert is enabled. If an activity log alert
     is not enabled, then none of its actions will be activated.
    :type enabled: bool
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        enabled: Optional[bool] = True,
        **kwargs
    ):
        super(ActivityLogAlertPatchBody, self).__init__(**kwargs)
        self.tags = tags
        self.enabled = enabled


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class ActivityLogAlertResource(Resource):
    """An activity log alert resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param scopes: A list of resourceIds that will be used as prefixes. The alert will only apply
     to activityLogs with resourceIds that fall under one of these prefixes. This list must include
     at least one item.
    :type scopes: list[str]
    :param enabled: Indicates whether this activity log alert is enabled. If an activity log alert
     is not enabled, then none of its actions will be activated.
    :type enabled: bool
    :param condition: The condition that will cause this alert to activate.
    :type condition: ~monitor_client.models.ActivityLogAlertAllOfCondition
    :param actions: The actions that will activate when the condition is met.
    :type actions: ~monitor_client.models.ActivityLogAlertActionList
    :param description: A description of this activity log alert.
    :type description: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'scopes': {'key': 'properties.scopes', 'type': '[str]'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'condition': {'key': 'properties.condition', 'type': 'ActivityLogAlertAllOfCondition'},
        'actions': {'key': 'properties.actions', 'type': 'ActivityLogAlertActionList'},
        'description': {'key': 'properties.description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        scopes: Optional[List[str]] = None,
        enabled: Optional[bool] = True,
        condition: Optional["ActivityLogAlertAllOfCondition"] = None,
        actions: Optional["ActivityLogAlertActionList"] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(ActivityLogAlertResource, self).__init__(location=location, tags=tags, **kwargs)
        self.scopes = scopes
        self.enabled = enabled
        self.condition = condition
        self.actions = actions
        self.description = description


class AlertingAction(Action):
    """Specify action need to be taken when rule type is Alert.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. Specifies the action. Supported values - AlertingAction,
     LogToMetricAction.Constant filled by server.
    :type odata_type: str
    :param severity: Required. Severity of the alert. Possible values include: '0', '1', '2', '3',
     '4'.
    :type severity: str or ~monitor_client.models.AlertSeverity
    :param azns_action: Azure action group reference.
    :type azns_action: ~monitor_client.models.AzNsActionGroup
    :param throttling_in_min: time (in minutes) for which Alerts should be throttled or suppressed.
    :type throttling_in_min: int
    :param trigger: Required. The trigger condition that results in the alert rule being.
    :type trigger: ~monitor_client.models.TriggerCondition
    """

    _validation = {
        'odata_type': {'required': True},
        'severity': {'required': True},
        'trigger': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'str'},
        'azns_action': {'key': 'aznsAction', 'type': 'AzNsActionGroup'},
        'throttling_in_min': {'key': 'throttlingInMin', 'type': 'int'},
        'trigger': {'key': 'trigger', 'type': 'TriggerCondition'},
    }

    def __init__(
        self,
        *,
        severity: Union[str, "AlertSeverity"],
        trigger: "TriggerCondition",
        azns_action: Optional["AzNsActionGroup"] = None,
        throttling_in_min: Optional[int] = None,
        **kwargs
    ):
        super(AlertingAction, self).__init__(**kwargs)
        self.odata_type = 'Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.AlertingAction'
        self.severity = severity
        self.azns_action = azns_action
        self.throttling_in_min = throttling_in_min
        self.trigger = trigger


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class AlertRuleResource(Resource):
    """The alert rule resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param name_properties_name: Required. the name of the alert rule.
    :type name_properties_name: str
    :param description: the description of the alert rule that will be included in the alert email.
    :type description: str
    :param is_enabled: Required. the flag that indicates whether the alert rule is enabled.
    :type is_enabled: bool
    :param condition: Required. the condition that results in the alert rule being activated.
    :type condition: ~monitor_client.models.RuleCondition
    :param actions: the array of actions that are performed when the alert rule becomes active, and
     when an alert condition is resolved.
    :type actions: list[~monitor_client.models.RuleAction]
    :ivar last_updated_time: Last time the rule was updated in ISO8601 format.
    :vartype last_updated_time: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'name_properties_name': {'required': True},
        'is_enabled': {'required': True},
        'condition': {'required': True},
        'last_updated_time': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'name_properties_name': {'key': 'properties.name', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'is_enabled': {'key': 'properties.isEnabled', 'type': 'bool'},
        'condition': {'key': 'properties.condition', 'type': 'RuleCondition'},
        'actions': {'key': 'properties.actions', 'type': '[RuleAction]'},
        'last_updated_time': {'key': 'properties.lastUpdatedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        location: str,
        name_properties_name: str,
        is_enabled: bool,
        condition: "RuleCondition",
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        actions: Optional[List["RuleAction"]] = None,
        **kwargs
    ):
        super(AlertRuleResource, self).__init__(location=location, tags=tags, **kwargs)
        self.name_properties_name = name_properties_name
        self.description = description
        self.is_enabled = is_enabled
        self.condition = condition
        self.actions = actions
        self.last_updated_time = None


class AlertRuleResourceCollection(msrest.serialization.Model):
    """Represents a collection of alert rule resources.

    :param value: the values for the alert rule resources.
    :type value: list[~monitor_client.models.AlertRuleResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AlertRuleResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["AlertRuleResource"]] = None,
        **kwargs
    ):
        super(AlertRuleResourceCollection, self).__init__(**kwargs)
        self.value = value


class AlertRuleResourcePatch(msrest.serialization.Model):
    """The alert rule object for patch operations.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param name: the name of the alert rule.
    :type name: str
    :param description: the description of the alert rule that will be included in the alert email.
    :type description: str
    :param is_enabled: the flag that indicates whether the alert rule is enabled.
    :type is_enabled: bool
    :param condition: the condition that results in the alert rule being activated.
    :type condition: ~monitor_client.models.RuleCondition
    :param actions: the array of actions that are performed when the alert rule becomes active, and
     when an alert condition is resolved.
    :type actions: list[~monitor_client.models.RuleAction]
    :ivar last_updated_time: Last time the rule was updated in ISO8601 format.
    :vartype last_updated_time: ~datetime.datetime
    """

    _validation = {
        'last_updated_time': {'readonly': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'name': {'key': 'properties.name', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'is_enabled': {'key': 'properties.isEnabled', 'type': 'bool'},
        'condition': {'key': 'properties.condition', 'type': 'RuleCondition'},
        'actions': {'key': 'properties.actions', 'type': '[RuleAction]'},
        'last_updated_time': {'key': 'properties.lastUpdatedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        condition: Optional["RuleCondition"] = None,
        actions: Optional[List["RuleAction"]] = None,
        **kwargs
    ):
        super(AlertRuleResourcePatch, self).__init__(**kwargs)
        self.tags = tags
        self.name = name
        self.description = description
        self.is_enabled = is_enabled
        self.condition = condition
        self.actions = actions
        self.last_updated_time = None


class ArmRoleReceiver(msrest.serialization.Model):
    """An arm role receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the arm role receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param role_id: Required. The arm role id.
    :type role_id: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    """

    _validation = {
        'name': {'required': True},
        'role_id': {'required': True},
        'use_common_alert_schema': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'role_id': {'key': 'roleId', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: str,
        role_id: str,
        use_common_alert_schema: bool,
        **kwargs
    ):
        super(ArmRoleReceiver, self).__init__(**kwargs)
        self.name = name
        self.role_id = role_id
        self.use_common_alert_schema = use_common_alert_schema


class AutomationRunbookReceiver(msrest.serialization.Model):
    """The Azure Automation Runbook notification receiver.

    All required parameters must be populated in order to send to Azure.

    :param automation_account_id: Required. The Azure automation account Id which holds this
     runbook and authenticate to Azure resource.
    :type automation_account_id: str
    :param runbook_name: Required. The name for this runbook.
    :type runbook_name: str
    :param webhook_resource_id: Required. The resource id for webhook linked to this runbook.
    :type webhook_resource_id: str
    :param is_global_runbook: Required. Indicates whether this instance is global runbook.
    :type is_global_runbook: bool
    :param name: Indicates name of the webhook.
    :type name: str
    :param service_uri: The URI where webhooks should be sent.
    :type service_uri: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    """

    _validation = {
        'automation_account_id': {'required': True},
        'runbook_name': {'required': True},
        'webhook_resource_id': {'required': True},
        'is_global_runbook': {'required': True},
        'use_common_alert_schema': {'required': True},
    }

    _attribute_map = {
        'automation_account_id': {'key': 'automationAccountId', 'type': 'str'},
        'runbook_name': {'key': 'runbookName', 'type': 'str'},
        'webhook_resource_id': {'key': 'webhookResourceId', 'type': 'str'},
        'is_global_runbook': {'key': 'isGlobalRunbook', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'service_uri': {'key': 'serviceUri', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        automation_account_id: str,
        runbook_name: str,
        webhook_resource_id: str,
        is_global_runbook: bool,
        use_common_alert_schema: bool,
        name: Optional[str] = None,
        service_uri: Optional[str] = None,
        **kwargs
    ):
        super(AutomationRunbookReceiver, self).__init__(**kwargs)
        self.automation_account_id = automation_account_id
        self.runbook_name = runbook_name
        self.webhook_resource_id = webhook_resource_id
        self.is_global_runbook = is_global_runbook
        self.name = name
        self.service_uri = service_uri
        self.use_common_alert_schema = use_common_alert_schema


class AutoscaleNotification(msrest.serialization.Model):
    """Autoscale notification.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar operation: Required. the operation associated with the notification and its value must be
     "scale". Default value: "Scale".
    :vartype operation: str
    :param email: the email notification.
    :type email: ~monitor_client.models.EmailNotification
    :param webhooks: the collection of webhook notifications.
    :type webhooks: list[~monitor_client.models.WebhookNotification]
    """

    _validation = {
        'operation': {'required': True, 'constant': True},
    }

    _attribute_map = {
        'operation': {'key': 'operation', 'type': 'str'},
        'email': {'key': 'email', 'type': 'EmailNotification'},
        'webhooks': {'key': 'webhooks', 'type': '[WebhookNotification]'},
    }

    operation = "Scale"

    def __init__(
        self,
        *,
        email: Optional["EmailNotification"] = None,
        webhooks: Optional[List["WebhookNotification"]] = None,
        **kwargs
    ):
        super(AutoscaleNotification, self).__init__(**kwargs)
        self.email = email
        self.webhooks = webhooks


class AutoscaleProfile(msrest.serialization.Model):
    """Autoscale profile.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. the name of the profile.
    :type name: str
    :param capacity: Required. the number of instances that can be used during this profile.
    :type capacity: ~monitor_client.models.ScaleCapacity
    :param rules: Required. the collection of rules that provide the triggers and parameters for
     the scaling action. A maximum of 10 rules can be specified.
    :type rules: list[~monitor_client.models.ScaleRule]
    :param fixed_date: the specific date-time for the profile. This element is not used if the
     Recurrence element is used.
    :type fixed_date: ~monitor_client.models.TimeWindow
    :param recurrence: the repeating times at which this profile begins. This element is not used
     if the FixedDate element is used.
    :type recurrence: ~monitor_client.models.Recurrence
    """

    _validation = {
        'name': {'required': True},
        'capacity': {'required': True},
        'rules': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'capacity': {'key': 'capacity', 'type': 'ScaleCapacity'},
        'rules': {'key': 'rules', 'type': '[ScaleRule]'},
        'fixed_date': {'key': 'fixedDate', 'type': 'TimeWindow'},
        'recurrence': {'key': 'recurrence', 'type': 'Recurrence'},
    }

    def __init__(
        self,
        *,
        name: str,
        capacity: "ScaleCapacity",
        rules: List["ScaleRule"],
        fixed_date: Optional["TimeWindow"] = None,
        recurrence: Optional["Recurrence"] = None,
        **kwargs
    ):
        super(AutoscaleProfile, self).__init__(**kwargs)
        self.name = name
        self.capacity = capacity
        self.rules = rules
        self.fixed_date = fixed_date
        self.recurrence = recurrence


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class AutoscaleSettingResource(Resource):
    """The autoscale setting resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param profiles: Required. the collection of automatic scaling profiles that specify different
     scaling parameters for different time periods. A maximum of 20 profiles can be specified.
    :type profiles: list[~monitor_client.models.AutoscaleProfile]
    :param notifications: the collection of notifications.
    :type notifications: list[~monitor_client.models.AutoscaleNotification]
    :param enabled: the enabled flag. Specifies whether automatic scaling is enabled for the
     resource. The default value is 'true'.
    :type enabled: bool
    :param name_properties_name: the name of the autoscale setting.
    :type name_properties_name: str
    :param target_resource_uri: the resource identifier of the resource that the autoscale setting
     should be added to.
    :type target_resource_uri: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'profiles': {'required': True, 'max_items': 20, 'min_items': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'profiles': {'key': 'properties.profiles', 'type': '[AutoscaleProfile]'},
        'notifications': {'key': 'properties.notifications', 'type': '[AutoscaleNotification]'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'name_properties_name': {'key': 'properties.name', 'type': 'str'},
        'target_resource_uri': {'key': 'properties.targetResourceUri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        location: str,
        profiles: List["AutoscaleProfile"],
        tags: Optional[Dict[str, str]] = None,
        notifications: Optional[List["AutoscaleNotification"]] = None,
        enabled: Optional[bool] = True,
        name_properties_name: Optional[str] = None,
        target_resource_uri: Optional[str] = None,
        **kwargs
    ):
        super(AutoscaleSettingResource, self).__init__(location=location, tags=tags, **kwargs)
        self.profiles = profiles
        self.notifications = notifications
        self.enabled = enabled
        self.name_properties_name = name_properties_name
        self.target_resource_uri = target_resource_uri


class AutoscaleSettingResourceCollection(msrest.serialization.Model):
    """Represents a collection of autoscale setting resources.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. the values for the autoscale setting resources.
    :type value: list[~monitor_client.models.AutoscaleSettingResource]
    :param next_link: URL to get the next set of results.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AutoscaleSettingResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: List["AutoscaleSettingResource"],
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(AutoscaleSettingResourceCollection, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class AutoscaleSettingResourcePatch(msrest.serialization.Model):
    """The autoscale setting object for patch operations.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param profiles: the collection of automatic scaling profiles that specify different scaling
     parameters for different time periods. A maximum of 20 profiles can be specified.
    :type profiles: list[~monitor_client.models.AutoscaleProfile]
    :param notifications: the collection of notifications.
    :type notifications: list[~monitor_client.models.AutoscaleNotification]
    :param enabled: the enabled flag. Specifies whether automatic scaling is enabled for the
     resource. The default value is 'true'.
    :type enabled: bool
    :param name: the name of the autoscale setting.
    :type name: str
    :param target_resource_uri: the resource identifier of the resource that the autoscale setting
     should be added to.
    :type target_resource_uri: str
    """

    _validation = {
        'profiles': {'max_items': 20, 'min_items': 0},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'profiles': {'key': 'properties.profiles', 'type': '[AutoscaleProfile]'},
        'notifications': {'key': 'properties.notifications', 'type': '[AutoscaleNotification]'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'name': {'key': 'properties.name', 'type': 'str'},
        'target_resource_uri': {'key': 'properties.targetResourceUri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        profiles: Optional[List["AutoscaleProfile"]] = None,
        notifications: Optional[List["AutoscaleNotification"]] = None,
        enabled: Optional[bool] = True,
        name: Optional[str] = None,
        target_resource_uri: Optional[str] = None,
        **kwargs
    ):
        super(AutoscaleSettingResourcePatch, self).__init__(**kwargs)
        self.tags = tags
        self.profiles = profiles
        self.notifications = notifications
        self.enabled = enabled
        self.name = name
        self.target_resource_uri = target_resource_uri


class AzNsActionGroup(msrest.serialization.Model):
    """Azure action group.

    :param action_group: Azure Action Group reference.
    :type action_group: list[str]
    :param email_subject: Custom subject override for all email ids in Azure action group.
    :type email_subject: str
    :param custom_webhook_payload: Custom payload to be sent for all webhook URI in Azure action
     group.
    :type custom_webhook_payload: str
    """

    _attribute_map = {
        'action_group': {'key': 'actionGroup', 'type': '[str]'},
        'email_subject': {'key': 'emailSubject', 'type': 'str'},
        'custom_webhook_payload': {'key': 'customWebhookPayload', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        action_group: Optional[List[str]] = None,
        email_subject: Optional[str] = None,
        custom_webhook_payload: Optional[str] = None,
        **kwargs
    ):
        super(AzNsActionGroup, self).__init__(**kwargs)
        self.action_group = action_group
        self.email_subject = email_subject
        self.custom_webhook_payload = custom_webhook_payload


class AzureAppPushReceiver(msrest.serialization.Model):
    """The Azure mobile App push notification receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the Azure mobile app push receiver. Names must be unique
     across all receivers within an action group.
    :type name: str
    :param email_address: Required. The email address registered for the Azure mobile app.
    :type email_address: str
    """

    _validation = {
        'name': {'required': True},
        'email_address': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'email_address': {'key': 'emailAddress', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        email_address: str,
        **kwargs
    ):
        super(AzureAppPushReceiver, self).__init__(**kwargs)
        self.name = name
        self.email_address = email_address


class AzureFunctionReceiver(msrest.serialization.Model):
    """An azure function receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the azure function receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param function_app_resource_id: Required. The azure resource id of the function app.
    :type function_app_resource_id: str
    :param function_name: Required. The function name in the function app.
    :type function_name: str
    :param http_trigger_url: Required. The http trigger url where http request sent to.
    :type http_trigger_url: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    """

    _validation = {
        'name': {'required': True},
        'function_app_resource_id': {'required': True},
        'function_name': {'required': True},
        'http_trigger_url': {'required': True},
        'use_common_alert_schema': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'function_app_resource_id': {'key': 'functionAppResourceId', 'type': 'str'},
        'function_name': {'key': 'functionName', 'type': 'str'},
        'http_trigger_url': {'key': 'httpTriggerUrl', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: str,
        function_app_resource_id: str,
        function_name: str,
        http_trigger_url: str,
        use_common_alert_schema: bool,
        **kwargs
    ):
        super(AzureFunctionReceiver, self).__init__(**kwargs)
        self.name = name
        self.function_app_resource_id = function_app_resource_id
        self.function_name = function_name
        self.http_trigger_url = http_trigger_url
        self.use_common_alert_schema = use_common_alert_schema


class Baseline(msrest.serialization.Model):
    """The baseline values for a single sensitivity value.

    All required parameters must be populated in order to send to Azure.

    :param sensitivity: Required. the sensitivity of the baseline. Possible values include: 'Low',
     'Medium', 'High'.
    :type sensitivity: str or ~monitor_client.models.Sensitivity
    :param low_thresholds: Required. The low thresholds of the baseline.
    :type low_thresholds: list[float]
    :param high_thresholds: Required. The high thresholds of the baseline.
    :type high_thresholds: list[float]
    """

    _validation = {
        'sensitivity': {'required': True},
        'low_thresholds': {'required': True},
        'high_thresholds': {'required': True},
    }

    _attribute_map = {
        'sensitivity': {'key': 'sensitivity', 'type': 'str'},
        'low_thresholds': {'key': 'lowThresholds', 'type': '[float]'},
        'high_thresholds': {'key': 'highThresholds', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        sensitivity: Union[str, "Sensitivity"],
        low_thresholds: List[float],
        high_thresholds: List[float],
        **kwargs
    ):
        super(Baseline, self).__init__(**kwargs)
        self.sensitivity = sensitivity
        self.low_thresholds = low_thresholds
        self.high_thresholds = high_thresholds


class BaselineMetadata(msrest.serialization.Model):
    """Represents a baseline metadata value.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the baseline metadata.
    :type name: str
    :param value: Required. Value of the baseline metadata.
    :type value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        value: str,
        **kwargs
    ):
        super(BaselineMetadata, self).__init__(**kwargs)
        self.name = name
        self.value = value


class BaselineMetadataValue(msrest.serialization.Model):
    """Represents a baseline metadata value.

    :param name: the name of the metadata.
    :type name: ~monitor_client.models.LocalizableString
    :param value: the value of the metadata.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'LocalizableString'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional["LocalizableString"] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(BaselineMetadataValue, self).__init__(**kwargs)
        self.name = name
        self.value = value


class BaselineResponse(msrest.serialization.Model):
    """The response to a baseline query.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: the metric baseline Id.
    :vartype id: str
    :ivar type: the resource type of the baseline resource.
    :vartype type: str
    :ivar name: the name and the display name of the metric, i.e. it is localizable string.
    :vartype name: ~monitor_client.models.LocalizableString
    :param timespan: The timespan for which the data was retrieved. Its value consists of two
     datetimes concatenated, separated by '/'.  This may be adjusted in the future and returned back
     from what was originally requested.
    :type timespan: str
    :param interval: The interval (window size) for which the metric data was returned in.  This
     may be adjusted in the future and returned back from what was originally requested.  This is
     not present if a metadata request was made.
    :type interval: ~datetime.timedelta
    :param aggregation: The aggregation type of the metric.
    :type aggregation: str
    :param timestamps: the array of timestamps of the baselines.
    :type timestamps: list[~datetime.datetime]
    :param baseline: the baseline values for each sensitivity.
    :type baseline: list[~monitor_client.models.Baseline]
    :param metadata: the baseline metadata values.
    :type metadata: list[~monitor_client.models.BaselineMetadataValue]
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'readonly': True},
        'name': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'LocalizableString'},
        'timespan': {'key': 'properties.timespan', 'type': 'str'},
        'interval': {'key': 'properties.interval', 'type': 'duration'},
        'aggregation': {'key': 'properties.aggregation', 'type': 'str'},
        'timestamps': {'key': 'properties.timestamps', 'type': '[iso-8601]'},
        'baseline': {'key': 'properties.baseline', 'type': '[Baseline]'},
        'metadata': {'key': 'properties.metadata', 'type': '[BaselineMetadataValue]'},
    }

    def __init__(
        self,
        *,
        timespan: Optional[str] = None,
        interval: Optional[datetime.timedelta] = None,
        aggregation: Optional[str] = None,
        timestamps: Optional[List[datetime.datetime]] = None,
        baseline: Optional[List["Baseline"]] = None,
        metadata: Optional[List["BaselineMetadataValue"]] = None,
        **kwargs
    ):
        super(BaselineResponse, self).__init__(**kwargs)
        self.id = None
        self.type = None
        self.name = None
        self.timespan = timespan
        self.interval = interval
        self.aggregation = aggregation
        self.timestamps = timestamps
        self.baseline = baseline
        self.metadata = metadata


class CalculateBaselineResponse(msrest.serialization.Model):
    """The response to a calculate baseline call.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. the resource type of the baseline resource.
    :type type: str
    :param timestamps: the array of timestamps of the baselines.
    :type timestamps: list[~datetime.datetime]
    :param baseline: Required. the baseline values for each sensitivity.
    :type baseline: list[~monitor_client.models.Baseline]
    """

    _validation = {
        'type': {'required': True},
        'baseline': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'timestamps': {'key': 'timestamps', 'type': '[iso-8601]'},
        'baseline': {'key': 'baseline', 'type': '[Baseline]'},
    }

    def __init__(
        self,
        *,
        type: str,
        baseline: List["Baseline"],
        timestamps: Optional[List[datetime.datetime]] = None,
        **kwargs
    ):
        super(CalculateBaselineResponse, self).__init__(**kwargs)
        self.type = type
        self.timestamps = timestamps
        self.baseline = baseline


class Criteria(msrest.serialization.Model):
    """Specifies the criteria for converting log to metric.

    All required parameters must be populated in order to send to Azure.

    :param metric_name: Required. Name of the metric.
    :type metric_name: str
    :param dimensions: List of Dimensions for creating metric.
    :type dimensions: list[~monitor_client.models.Dimension]
    """

    _validation = {
        'metric_name': {'required': True},
    }

    _attribute_map = {
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[Dimension]'},
    }

    def __init__(
        self,
        *,
        metric_name: str,
        dimensions: Optional[List["Dimension"]] = None,
        **kwargs
    ):
        super(Criteria, self).__init__(**kwargs)
        self.metric_name = metric_name
        self.dimensions = dimensions


class DataContainer(msrest.serialization.Model):
    """Information about a container with data for a given resource.

    All required parameters must be populated in order to send to Azure.

    :param workspace: Required. Log Analytics workspace information.
    :type workspace: ~monitor_client.models.WorkspaceInfo
    """

    _validation = {
        'workspace': {'required': True},
    }

    _attribute_map = {
        'workspace': {'key': 'workspace', 'type': 'WorkspaceInfo'},
    }

    def __init__(
        self,
        *,
        workspace: "WorkspaceInfo",
        **kwargs
    ):
        super(DataContainer, self).__init__(**kwargs)
        self.workspace = workspace


class ProxyOnlyResource(msrest.serialization.Model):
    """A proxy only azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ProxyOnlyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None


class DiagnosticSettingsCategoryResource(ProxyOnlyResource):
    """The diagnostic settings category resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param category_type: The type of the diagnostic settings category. Possible values include:
     'Metrics', 'Logs'.
    :type category_type: str or ~monitor_client.models.CategoryType
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'category_type': {'key': 'properties.categoryType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        category_type: Optional[Union[str, "CategoryType"]] = None,
        **kwargs
    ):
        super(DiagnosticSettingsCategoryResource, self).__init__(**kwargs)
        self.category_type = category_type


class DiagnosticSettingsCategoryResourceCollection(msrest.serialization.Model):
    """Represents a collection of diagnostic setting category resources.

    :param value: The collection of diagnostic settings category resources.
    :type value: list[~monitor_client.models.DiagnosticSettingsCategoryResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[DiagnosticSettingsCategoryResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["DiagnosticSettingsCategoryResource"]] = None,
        **kwargs
    ):
        super(DiagnosticSettingsCategoryResourceCollection, self).__init__(**kwargs)
        self.value = value


class ProxyOnlyResource(msrest.serialization.Model):
    """A proxy only azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ProxyOnlyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None


class DiagnosticSettingsResource(ProxyOnlyResource):
    """The diagnostic setting resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param storage_account_id: The resource ID of the storage account to which you would like to
     send Diagnostic Logs.
    :type storage_account_id: str
    :param service_bus_rule_id: The service bus rule Id of the diagnostic setting. This is here to
     maintain backwards compatibility.
    :type service_bus_rule_id: str
    :param event_hub_authorization_rule_id: The resource Id for the event hub authorization rule.
    :type event_hub_authorization_rule_id: str
    :param event_hub_name: The name of the event hub. If none is specified, the default event hub
     will be selected.
    :type event_hub_name: str
    :param metrics: The list of metric settings.
    :type metrics: list[~monitor_client.models.MetricSettings]
    :param logs: The list of logs settings.
    :type logs: list[~monitor_client.models.LogSettings]
    :param workspace_id: The full ARM resource ID of the Log Analytics workspace to which you would
     like to send Diagnostic Logs. Example:
     /subscriptions/4b9e8510-67ab-4e9a-95a9-e2f1e570ea9c/resourceGroups/insights-
     integration/providers/Microsoft.OperationalInsights/workspaces/viruela2.
    :type workspace_id: str
    :param log_analytics_destination_type: A string indicating whether the export to Log Analytics
     should use the default destination type, i.e. AzureDiagnostics, or use a destination type
     constructed as follows: :code:`<normalized service identity>`_:code:`<normalized category
     name>`. Possible values are: Dedicated and null (null is default.).
    :type log_analytics_destination_type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'storage_account_id': {'key': 'properties.storageAccountId', 'type': 'str'},
        'service_bus_rule_id': {'key': 'properties.serviceBusRuleId', 'type': 'str'},
        'event_hub_authorization_rule_id': {'key': 'properties.eventHubAuthorizationRuleId', 'type': 'str'},
        'event_hub_name': {'key': 'properties.eventHubName', 'type': 'str'},
        'metrics': {'key': 'properties.metrics', 'type': '[MetricSettings]'},
        'logs': {'key': 'properties.logs', 'type': '[LogSettings]'},
        'workspace_id': {'key': 'properties.workspaceId', 'type': 'str'},
        'log_analytics_destination_type': {'key': 'properties.logAnalyticsDestinationType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        storage_account_id: Optional[str] = None,
        service_bus_rule_id: Optional[str] = None,
        event_hub_authorization_rule_id: Optional[str] = None,
        event_hub_name: Optional[str] = None,
        metrics: Optional[List["MetricSettings"]] = None,
        logs: Optional[List["LogSettings"]] = None,
        workspace_id: Optional[str] = None,
        log_analytics_destination_type: Optional[str] = None,
        **kwargs
    ):
        super(DiagnosticSettingsResource, self).__init__(**kwargs)
        self.storage_account_id = storage_account_id
        self.service_bus_rule_id = service_bus_rule_id
        self.event_hub_authorization_rule_id = event_hub_authorization_rule_id
        self.event_hub_name = event_hub_name
        self.metrics = metrics
        self.logs = logs
        self.workspace_id = workspace_id
        self.log_analytics_destination_type = log_analytics_destination_type


class DiagnosticSettingsResourceCollection(msrest.serialization.Model):
    """Represents a collection of alert rule resources.

    :param value: The collection of diagnostic settings resources;.
    :type value: list[~monitor_client.models.DiagnosticSettingsResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[DiagnosticSettingsResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["DiagnosticSettingsResource"]] = None,
        **kwargs
    ):
        super(DiagnosticSettingsResourceCollection, self).__init__(**kwargs)
        self.value = value


class Dimension(msrest.serialization.Model):
    """Specifies the criteria for converting log to metric.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the dimension.
    :type name: str
    :param operator: Required. Operator for dimension values. Possible values include: 'Equals',
     'NotEquals', 'GreaterThan', 'GreaterThanOrEqual', 'LessThan', 'LessThanOrEqual', 'Include'.
    :type operator: str or ~monitor_client.models.Operator
    :param values: Required. List of dimension values.
    :type values: list[str]
    """

    _validation = {
        'name': {'required': True},
        'operator': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'operator': {'key': 'operator', 'type': 'str'},
        'values': {'key': 'values', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: str,
        operator: Union[str, "Operator"],
        values: List[str],
        **kwargs
    ):
        super(Dimension, self).__init__(**kwargs)
        self.name = name
        self.operator = operator
        self.values = values


class MultiMetricCriteria(msrest.serialization.Model):
    """The types of conditions for a multi resource alert.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: DynamicMetricCriteria, MetricCriteria.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param criterion_type: Required. Specifies the type of threshold criteria.Constant filled by
     server.  Possible values include: 'StaticThresholdCriterion', 'DynamicThresholdCriterion'.
    :type criterion_type: str or ~monitor_client.models.CriterionType
    :param name: Required. Name of the criteria.
    :type name: str
    :param metric_name: Required. Name of the metric.
    :type metric_name: str
    :param metric_namespace: Namespace of the metric.
    :type metric_namespace: str
    :param time_aggregation: Required. the criteria time aggregation types. Possible values
     include: 'None', 'Average', 'Count', 'Minimum', 'Maximum', 'Total'.
    :type time_aggregation: str or ~monitor_client.models.AggregationType
    :param dimensions: List of dimension conditions.
    :type dimensions: list[~monitor_client.models.MetricDimension]
    """

    _validation = {
        'criterion_type': {'required': True},
        'name': {'required': True},
        'metric_name': {'required': True},
        'time_aggregation': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'criterion_type': {'key': 'criterionType', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
        'time_aggregation': {'key': 'timeAggregation', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[MetricDimension]'},
    }

    _subtype_map = {
        'criterion_type': {'DynamicThresholdCriterion': 'DynamicMetricCriteria', 'StaticThresholdCriterion': 'MetricCriteria'}
    }

    def __init__(
        self,
        *,
        name: str,
        metric_name: str,
        time_aggregation: Union[str, "AggregationType"],
        additional_properties: Optional[Dict[str, object]] = None,
        metric_namespace: Optional[str] = None,
        dimensions: Optional[List["MetricDimension"]] = None,
        **kwargs
    ):
        super(MultiMetricCriteria, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.criterion_type = 'MultiMetricCriteria'
        self.name = name
        self.metric_name = metric_name
        self.metric_namespace = metric_namespace
        self.time_aggregation = time_aggregation
        self.dimensions = dimensions


class DynamicMetricCriteria(MultiMetricCriteria):
    """Criterion for dynamic threshold.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param criterion_type: Required. Specifies the type of threshold criteria.Constant filled by
     server.  Possible values include: 'StaticThresholdCriterion', 'DynamicThresholdCriterion'.
    :type criterion_type: str or ~monitor_client.models.CriterionType
    :param name: Required. Name of the criteria.
    :type name: str
    :param metric_name: Required. Name of the metric.
    :type metric_name: str
    :param metric_namespace: Namespace of the metric.
    :type metric_namespace: str
    :param time_aggregation: Required. the criteria time aggregation types. Possible values
     include: 'None', 'Average', 'Count', 'Minimum', 'Maximum', 'Total'.
    :type time_aggregation: str or ~monitor_client.models.AggregationType
    :param dimensions: List of dimension conditions.
    :type dimensions: list[~monitor_client.models.MetricDimension]
    :param operator: Required. The operator used to compare the metric value against the threshold.
     Possible values include: 'GreaterThan', 'LessThan', 'GreaterOrLessThan'.
    :type operator: str or ~monitor_client.models.DynamicThresholdOperator
    :param alert_sensitivity: Required. The extent of deviation required to trigger an alert. This
     will affect how tight the threshold is to the metric series pattern. Possible values include:
     'Low', 'Medium', 'High'.
    :type alert_sensitivity: str or ~monitor_client.models.DynamicThresholdSensitivity
    :param failing_periods: Required. The minimum number of violations required within the selected
     lookback time window required to raise an alert.
    :type failing_periods: ~monitor_client.models.DynamicThresholdFailingPeriods
    :param ignore_data_before: Use this option to set the date from which to start learning the
     metric historical data and calculate the dynamic thresholds (in ISO8601 format).
    :type ignore_data_before: ~datetime.datetime
    """

    _validation = {
        'criterion_type': {'required': True},
        'name': {'required': True},
        'metric_name': {'required': True},
        'time_aggregation': {'required': True},
        'operator': {'required': True},
        'alert_sensitivity': {'required': True},
        'failing_periods': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'criterion_type': {'key': 'criterionType', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
        'time_aggregation': {'key': 'timeAggregation', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[MetricDimension]'},
        'operator': {'key': 'operator', 'type': 'str'},
        'alert_sensitivity': {'key': 'alertSensitivity', 'type': 'str'},
        'failing_periods': {'key': 'failingPeriods', 'type': 'DynamicThresholdFailingPeriods'},
        'ignore_data_before': {'key': 'ignoreDataBefore', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        name: str,
        metric_name: str,
        time_aggregation: Union[str, "AggregationType"],
        operator: Union[str, "DynamicThresholdOperator"],
        alert_sensitivity: Union[str, "DynamicThresholdSensitivity"],
        failing_periods: "DynamicThresholdFailingPeriods",
        additional_properties: Optional[Dict[str, object]] = None,
        metric_namespace: Optional[str] = None,
        dimensions: Optional[List["MetricDimension"]] = None,
        ignore_data_before: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(DynamicMetricCriteria, self).__init__(additional_properties=additional_properties, name=name, metric_name=metric_name, metric_namespace=metric_namespace, time_aggregation=time_aggregation, dimensions=dimensions, **kwargs)
        self.criterion_type = 'DynamicThresholdCriterion'
        self.operator = operator
        self.alert_sensitivity = alert_sensitivity
        self.failing_periods = failing_periods
        self.ignore_data_before = ignore_data_before


class DynamicThresholdFailingPeriods(msrest.serialization.Model):
    """The minimum number of violations required within the selected lookback time window required to raise an alert.

    All required parameters must be populated in order to send to Azure.

    :param number_of_evaluation_periods: Required. The number of aggregated lookback points. The
     lookback time window is calculated based on the aggregation granularity (windowSize) and the
     selected number of aggregated points.
    :type number_of_evaluation_periods: float
    :param min_failing_periods_to_alert: Required. The number of violations to trigger an alert.
     Should be smaller or equal to numberOfEvaluationPeriods.
    :type min_failing_periods_to_alert: float
    """

    _validation = {
        'number_of_evaluation_periods': {'required': True},
        'min_failing_periods_to_alert': {'required': True},
    }

    _attribute_map = {
        'number_of_evaluation_periods': {'key': 'numberOfEvaluationPeriods', 'type': 'float'},
        'min_failing_periods_to_alert': {'key': 'minFailingPeriodsToAlert', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        number_of_evaluation_periods: float,
        min_failing_periods_to_alert: float,
        **kwargs
    ):
        super(DynamicThresholdFailingPeriods, self).__init__(**kwargs)
        self.number_of_evaluation_periods = number_of_evaluation_periods
        self.min_failing_periods_to_alert = min_failing_periods_to_alert


class EmailNotification(msrest.serialization.Model):
    """Email notification of an autoscale event.

    :param send_to_subscription_administrator: a value indicating whether to send email to
     subscription administrator.
    :type send_to_subscription_administrator: bool
    :param send_to_subscription_co_administrators: a value indicating whether to send email to
     subscription co-administrators.
    :type send_to_subscription_co_administrators: bool
    :param custom_emails: the custom e-mails list. This value can be null or empty, in which case
     this attribute will be ignored.
    :type custom_emails: list[str]
    """

    _attribute_map = {
        'send_to_subscription_administrator': {'key': 'sendToSubscriptionAdministrator', 'type': 'bool'},
        'send_to_subscription_co_administrators': {'key': 'sendToSubscriptionCoAdministrators', 'type': 'bool'},
        'custom_emails': {'key': 'customEmails', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        send_to_subscription_administrator: Optional[bool] = None,
        send_to_subscription_co_administrators: Optional[bool] = None,
        custom_emails: Optional[List[str]] = None,
        **kwargs
    ):
        super(EmailNotification, self).__init__(**kwargs)
        self.send_to_subscription_administrator = send_to_subscription_administrator
        self.send_to_subscription_co_administrators = send_to_subscription_co_administrators
        self.custom_emails = custom_emails


class EmailReceiver(msrest.serialization.Model):
    """An email receiver.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the email receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param email_address: Required. The email address of this receiver.
    :type email_address: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    :ivar status: The receiver status of the e-mail. Possible values include: 'NotSpecified',
     'Enabled', 'Disabled'.
    :vartype status: str or ~monitor_client.models.ReceiverStatus
    """

    _validation = {
        'name': {'required': True},
        'email_address': {'required': True},
        'use_common_alert_schema': {'required': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'email_address': {'key': 'emailAddress', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        email_address: str,
        use_common_alert_schema: bool,
        **kwargs
    ):
        super(EmailReceiver, self).__init__(**kwargs)
        self.name = name
        self.email_address = email_address
        self.use_common_alert_schema = use_common_alert_schema
        self.status = None


class EnableRequest(msrest.serialization.Model):
    """Describes a receiver that should be resubscribed.

    All required parameters must be populated in order to send to Azure.

    :param receiver_name: Required. The name of the receiver to resubscribe.
    :type receiver_name: str
    """

    _validation = {
        'receiver_name': {'required': True},
    }

    _attribute_map = {
        'receiver_name': {'key': 'receiverName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        receiver_name: str,
        **kwargs
    ):
        super(EnableRequest, self).__init__(**kwargs)
        self.receiver_name = receiver_name


class Error(msrest.serialization.Model):
    """Error details.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. Error code identifying the specific error.
    :type code: str
    :param message: Error message in the caller's locale.
    :type message: str
    """

    _validation = {
        'code': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: str,
        message: Optional[str] = None,
        **kwargs
    ):
        super(Error, self).__init__(**kwargs)
        self.code = code
        self.message = message


class ErrorResponse(msrest.serialization.Model):
    """Describes the format of Error response.

    :param code: Error code.
    :type code: str
    :param message: Error message indicating why the operation failed.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.code = code
        self.message = message


class EventCategoryCollection(msrest.serialization.Model):
    """A collection of event categories. Currently possible values are: Administrative, Security, ServiceHealth, Alert, Recommendation, Policy.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. the list that includes the Azure event categories.
    :type value: list[~monitor_client.models.LocalizableString]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LocalizableString]'},
    }

    def __init__(
        self,
        *,
        value: List["LocalizableString"],
        **kwargs
    ):
        super(EventCategoryCollection, self).__init__(**kwargs)
        self.value = value


class EventData(msrest.serialization.Model):
    """The Azure event log entries are of type EventData.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar authorization: The sender authorization information.
    :vartype authorization: ~monitor_client.models.SenderAuthorization
    :ivar claims: key value pairs to identify ARM permissions.
    :vartype claims: dict[str, str]
    :ivar caller: the email address of the user who has performed the operation, the UPN claim or
     SPN claim based on availability.
    :vartype caller: str
    :ivar description: the description of the event.
    :vartype description: str
    :ivar id: the Id of this event as required by ARM for RBAC. It contains the EventDataID and a
     timestamp information.
    :vartype id: str
    :ivar event_data_id: the event data Id. This is a unique identifier for an event.
    :vartype event_data_id: str
    :ivar correlation_id: the correlation Id, usually a GUID in the string format. The correlation
     Id is shared among the events that belong to the same uber operation.
    :vartype correlation_id: str
    :ivar event_name: the event name. This value should not be confused with OperationName. For
     practical purposes, OperationName might be more appealing to end users.
    :vartype event_name: ~monitor_client.models.LocalizableString
    :ivar category: the event category.
    :vartype category: ~monitor_client.models.LocalizableString
    :ivar http_request: the HTTP request info. Usually includes the 'clientRequestId',
     'clientIpAddress' (IP address of the user who initiated the event) and 'method' (HTTP method
     e.g. PUT).
    :vartype http_request: ~monitor_client.models.HttpRequestInfo
    :ivar level: the event level. Possible values include: 'Critical', 'Error', 'Warning',
     'Informational', 'Verbose'.
    :vartype level: str or ~monitor_client.models.EventLevel
    :ivar resource_group_name: the resource group name of the impacted resource.
    :vartype resource_group_name: str
    :ivar resource_provider_name: the resource provider name of the impacted resource.
    :vartype resource_provider_name: ~monitor_client.models.LocalizableString
    :ivar resource_id: the resource uri that uniquely identifies the resource that caused this
     event.
    :vartype resource_id: str
    :ivar resource_type: the resource type.
    :vartype resource_type: ~monitor_client.models.LocalizableString
    :ivar operation_id: It is usually a GUID shared among the events corresponding to single
     operation. This value should not be confused with EventName.
    :vartype operation_id: str
    :ivar operation_name: the operation name.
    :vartype operation_name: ~monitor_client.models.LocalizableString
    :ivar properties: the set of <Key, Value> pairs (usually a Dictionary<String, String>) that
     includes details about the event.
    :vartype properties: dict[str, str]
    :ivar status: a string describing the status of the operation. Some typical values are:
     Started, In progress, Succeeded, Failed, Resolved.
    :vartype status: ~monitor_client.models.LocalizableString
    :ivar sub_status: the event sub status. Most of the time, when included, this captures the HTTP
     status code of the REST call. Common values are: OK (HTTP Status Code: 200), Created (HTTP
     Status Code: 201), Accepted (HTTP Status Code: 202), No Content (HTTP Status Code: 204), Bad
     Request(HTTP Status Code: 400), Not Found (HTTP Status Code: 404), Conflict (HTTP Status Code:
     409), Internal Server Error (HTTP Status Code: 500), Service Unavailable (HTTP Status
     Code:503), Gateway Timeout (HTTP Status Code: 504).
    :vartype sub_status: ~monitor_client.models.LocalizableString
    :ivar event_timestamp: the timestamp of when the event was generated by the Azure service
     processing the request corresponding the event. It in ISO 8601 format.
    :vartype event_timestamp: ~datetime.datetime
    :ivar submission_timestamp: the timestamp of when the event became available for querying via
     this API. It is in ISO 8601 format. This value should not be confused eventTimestamp. As there
     might be a delay between the occurrence time of the event, and the time that the event is
     submitted to the Azure logging infrastructure.
    :vartype submission_timestamp: ~datetime.datetime
    :ivar subscription_id: the Azure subscription Id usually a GUID.
    :vartype subscription_id: str
    :ivar tenant_id: the Azure tenant Id.
    :vartype tenant_id: str
    """

    _validation = {
        'authorization': {'readonly': True},
        'claims': {'readonly': True},
        'caller': {'readonly': True},
        'description': {'readonly': True},
        'id': {'readonly': True},
        'event_data_id': {'readonly': True},
        'correlation_id': {'readonly': True},
        'event_name': {'readonly': True},
        'category': {'readonly': True},
        'http_request': {'readonly': True},
        'level': {'readonly': True},
        'resource_group_name': {'readonly': True},
        'resource_provider_name': {'readonly': True},
        'resource_id': {'readonly': True},
        'resource_type': {'readonly': True},
        'operation_id': {'readonly': True},
        'operation_name': {'readonly': True},
        'properties': {'readonly': True},
        'status': {'readonly': True},
        'sub_status': {'readonly': True},
        'event_timestamp': {'readonly': True},
        'submission_timestamp': {'readonly': True},
        'subscription_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'authorization': {'key': 'authorization', 'type': 'SenderAuthorization'},
        'claims': {'key': 'claims', 'type': '{str}'},
        'caller': {'key': 'caller', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'event_data_id': {'key': 'eventDataId', 'type': 'str'},
        'correlation_id': {'key': 'correlationId', 'type': 'str'},
        'event_name': {'key': 'eventName', 'type': 'LocalizableString'},
        'category': {'key': 'category', 'type': 'LocalizableString'},
        'http_request': {'key': 'httpRequest', 'type': 'HttpRequestInfo'},
        'level': {'key': 'level', 'type': 'str'},
        'resource_group_name': {'key': 'resourceGroupName', 'type': 'str'},
        'resource_provider_name': {'key': 'resourceProviderName', 'type': 'LocalizableString'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'resource_type': {'key': 'resourceType', 'type': 'LocalizableString'},
        'operation_id': {'key': 'operationId', 'type': 'str'},
        'operation_name': {'key': 'operationName', 'type': 'LocalizableString'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'status': {'key': 'status', 'type': 'LocalizableString'},
        'sub_status': {'key': 'subStatus', 'type': 'LocalizableString'},
        'event_timestamp': {'key': 'eventTimestamp', 'type': 'iso-8601'},
        'submission_timestamp': {'key': 'submissionTimestamp', 'type': 'iso-8601'},
        'subscription_id': {'key': 'subscriptionId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(EventData, self).__init__(**kwargs)
        self.authorization = None
        self.claims = None
        self.caller = None
        self.description = None
        self.id = None
        self.event_data_id = None
        self.correlation_id = None
        self.event_name = None
        self.category = None
        self.http_request = None
        self.level = None
        self.resource_group_name = None
        self.resource_provider_name = None
        self.resource_id = None
        self.resource_type = None
        self.operation_id = None
        self.operation_name = None
        self.properties = None
        self.status = None
        self.sub_status = None
        self.event_timestamp = None
        self.submission_timestamp = None
        self.subscription_id = None
        self.tenant_id = None


class EventDataCollection(msrest.serialization.Model):
    """Represents collection of events.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. this list that includes the Azure audit logs.
    :type value: list[~monitor_client.models.EventData]
    :param next_link: Provides the link to retrieve the next set of events.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[EventData]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: List["EventData"],
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(EventDataCollection, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class HttpRequestInfo(msrest.serialization.Model):
    """The Http request info.

    :param client_request_id: the client request id.
    :type client_request_id: str
    :param client_ip_address: the client Ip Address.
    :type client_ip_address: str
    :param method: the Http request method.
    :type method: str
    :param uri: the Uri.
    :type uri: str
    """

    _attribute_map = {
        'client_request_id': {'key': 'clientRequestId', 'type': 'str'},
        'client_ip_address': {'key': 'clientIpAddress', 'type': 'str'},
        'method': {'key': 'method', 'type': 'str'},
        'uri': {'key': 'uri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        client_request_id: Optional[str] = None,
        client_ip_address: Optional[str] = None,
        method: Optional[str] = None,
        uri: Optional[str] = None,
        **kwargs
    ):
        super(HttpRequestInfo, self).__init__(**kwargs)
        self.client_request_id = client_request_id
        self.client_ip_address = client_ip_address
        self.method = method
        self.uri = uri


class Incident(msrest.serialization.Model):
    """An alert incident indicates the activation status of an alert rule.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: Incident name.
    :vartype name: str
    :ivar rule_name: Rule name that is associated with the incident.
    :vartype rule_name: str
    :ivar is_active: A boolean to indicate whether the incident is active or resolved.
    :vartype is_active: bool
    :ivar activated_time: The time at which the incident was activated in ISO8601 format.
    :vartype activated_time: ~datetime.datetime
    :ivar resolved_time: The time at which the incident was resolved in ISO8601 format. If null, it
     means the incident is still active.
    :vartype resolved_time: ~datetime.datetime
    """

    _validation = {
        'name': {'readonly': True},
        'rule_name': {'readonly': True},
        'is_active': {'readonly': True},
        'activated_time': {'readonly': True},
        'resolved_time': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'rule_name': {'key': 'ruleName', 'type': 'str'},
        'is_active': {'key': 'isActive', 'type': 'bool'},
        'activated_time': {'key': 'activatedTime', 'type': 'iso-8601'},
        'resolved_time': {'key': 'resolvedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Incident, self).__init__(**kwargs)
        self.name = None
        self.rule_name = None
        self.is_active = None
        self.activated_time = None
        self.resolved_time = None


class IncidentListResult(msrest.serialization.Model):
    """The List incidents operation response.

    :param value: the incident collection.
    :type value: list[~monitor_client.models.Incident]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Incident]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Incident"]] = None,
        **kwargs
    ):
        super(IncidentListResult, self).__init__(**kwargs)
        self.value = value


class ItsmReceiver(msrest.serialization.Model):
    """An Itsm receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the Itsm receiver. Names must be unique across all receivers
     within an action group.
    :type name: str
    :param workspace_id: Required. OMS LA instance identifier.
    :type workspace_id: str
    :param connection_id: Required. Unique identification of ITSM connection among multiple defined
     in above workspace.
    :type connection_id: str
    :param ticket_configuration: Required. JSON blob for the configurations of the ITSM action.
     CreateMultipleWorkItems option will be part of this blob as well.
    :type ticket_configuration: str
    :param region: Required. Region in which workspace resides. Supported
     values:'centralindia','japaneast','southeastasia','australiasoutheast','uksouth','westcentralus','canadacentral','eastus','westeurope'.
    :type region: str
    """

    _validation = {
        'name': {'required': True},
        'workspace_id': {'required': True},
        'connection_id': {'required': True},
        'ticket_configuration': {'required': True},
        'region': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'workspace_id': {'key': 'workspaceId', 'type': 'str'},
        'connection_id': {'key': 'connectionId', 'type': 'str'},
        'ticket_configuration': {'key': 'ticketConfiguration', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        workspace_id: str,
        connection_id: str,
        ticket_configuration: str,
        region: str,
        **kwargs
    ):
        super(ItsmReceiver, self).__init__(**kwargs)
        self.name = name
        self.workspace_id = workspace_id
        self.connection_id = connection_id
        self.ticket_configuration = ticket_configuration
        self.region = region


class LocalizableString(msrest.serialization.Model):
    """The localizable string class.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. the invariant value.
    :type value: str
    :param localized_value: the locale specific value.
    :type localized_value: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
        'localized_value': {'key': 'localizedValue', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: str,
        localized_value: Optional[str] = None,
        **kwargs
    ):
        super(LocalizableString, self).__init__(**kwargs)
        self.value = value
        self.localized_value = localized_value


class RuleCondition(msrest.serialization.Model):
    """The condition that results in the alert rule being activated.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: LocationThresholdRuleCondition, ManagementEventRuleCondition, ThresholdRuleCondition.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of condition. This can be one of three types:
     ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition
     (based on the number of failures of a web test), and ThresholdRuleCondition (based on the
     threshold of a metric).Constant filled by server.
    :type odata_type: str
    :param data_source: the resource from which the rule collects its data. For this type
     dataSource will always be of type RuleMetricDataSource.
    :type data_source: ~monitor_client.models.RuleDataSource
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'data_source': {'key': 'dataSource', 'type': 'RuleDataSource'},
    }

    _subtype_map = {
        'odata_type': {'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition': 'LocationThresholdRuleCondition', 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition': 'ManagementEventRuleCondition', 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition': 'ThresholdRuleCondition'}
    }

    def __init__(
        self,
        *,
        data_source: Optional["RuleDataSource"] = None,
        **kwargs
    ):
        super(RuleCondition, self).__init__(**kwargs)
        self.odata_type = None
        self.data_source = data_source


class LocationThresholdRuleCondition(RuleCondition):
    """A rule condition based on a certain number of locations failing.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of condition. This can be one of three types:
     ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition
     (based on the number of failures of a web test), and ThresholdRuleCondition (based on the
     threshold of a metric).Constant filled by server.
    :type odata_type: str
    :param data_source: the resource from which the rule collects its data. For this type
     dataSource will always be of type RuleMetricDataSource.
    :type data_source: ~monitor_client.models.RuleDataSource
    :param window_size: the period of time (in ISO 8601 duration format) that is used to monitor
     alert activity based on the threshold. If specified then it must be between 5 minutes and 1
     day.
    :type window_size: ~datetime.timedelta
    :param failed_location_count: Required. the number of locations that must fail to activate the
     alert.
    :type failed_location_count: int
    """

    _validation = {
        'odata_type': {'required': True},
        'failed_location_count': {'required': True, 'minimum': 0},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'data_source': {'key': 'dataSource', 'type': 'RuleDataSource'},
        'window_size': {'key': 'windowSize', 'type': 'duration'},
        'failed_location_count': {'key': 'failedLocationCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        failed_location_count: int,
        data_source: Optional["RuleDataSource"] = None,
        window_size: Optional[datetime.timedelta] = None,
        **kwargs
    ):
        super(LocationThresholdRuleCondition, self).__init__(data_source=data_source, **kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'
        self.window_size = window_size
        self.failed_location_count = failed_location_count


class LogicAppReceiver(msrest.serialization.Model):
    """A logic app receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the logic app receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param resource_id: Required. The azure resource id of the logic app receiver.
    :type resource_id: str
    :param callback_url: Required. The callback url where http request sent to.
    :type callback_url: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    """

    _validation = {
        'name': {'required': True},
        'resource_id': {'required': True},
        'callback_url': {'required': True},
        'use_common_alert_schema': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'callback_url': {'key': 'callbackUrl', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: str,
        resource_id: str,
        callback_url: str,
        use_common_alert_schema: bool,
        **kwargs
    ):
        super(LogicAppReceiver, self).__init__(**kwargs)
        self.name = name
        self.resource_id = resource_id
        self.callback_url = callback_url
        self.use_common_alert_schema = use_common_alert_schema


class LogMetricTrigger(msrest.serialization.Model):
    """A log metrics trigger descriptor.

    :param threshold_operator: Evaluation operation for Metric -'GreaterThan' or 'LessThan' or
     'Equal'. Possible values include: 'GreaterThan', 'LessThan', 'Equal'.
    :type threshold_operator: str or ~monitor_client.models.ConditionalOperator
    :param threshold: The threshold of the metric trigger.
    :type threshold: float
    :param metric_trigger_type: Metric Trigger Type - 'Consecutive' or 'Total'. Possible values
     include: 'Consecutive', 'Total'.
    :type metric_trigger_type: str or ~monitor_client.models.MetricTriggerType
    :param metric_column: Evaluation of metric on a particular column.
    :type metric_column: str
    """

    _attribute_map = {
        'threshold_operator': {'key': 'thresholdOperator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
        'metric_trigger_type': {'key': 'metricTriggerType', 'type': 'str'},
        'metric_column': {'key': 'metricColumn', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        threshold_operator: Optional[Union[str, "ConditionalOperator"]] = None,
        threshold: Optional[float] = None,
        metric_trigger_type: Optional[Union[str, "MetricTriggerType"]] = None,
        metric_column: Optional[str] = None,
        **kwargs
    ):
        super(LogMetricTrigger, self).__init__(**kwargs)
        self.threshold_operator = threshold_operator
        self.threshold = threshold
        self.metric_trigger_type = metric_trigger_type
        self.metric_column = metric_column


class LogProfileCollection(msrest.serialization.Model):
    """Represents a collection of log profiles.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. the values of the log profiles.
    :type value: list[~monitor_client.models.LogProfileResource]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LogProfileResource]'},
    }

    def __init__(
        self,
        *,
        value: List["LogProfileResource"],
        **kwargs
    ):
        super(LogProfileCollection, self).__init__(**kwargs)
        self.value = value


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class LogProfileResource(Resource):
    """The log profile resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param storage_account_id: the resource id of the storage account to which you would like to
     send the Activity Log.
    :type storage_account_id: str
    :param service_bus_rule_id: The service bus rule ID of the service bus namespace in which you
     would like to have Event Hubs created for streaming the Activity Log. The rule ID is of the
     format: '{service bus resource ID}/authorizationrules/{key name}'.
    :type service_bus_rule_id: str
    :param locations: Required. List of regions for which Activity Log events should be stored or
     streamed. It is a comma separated list of valid ARM locations including the 'global' location.
    :type locations: list[str]
    :param categories: Required. the categories of the logs. These categories are created as is
     convenient to the user. Some values are: 'Write', 'Delete', and/or 'Action.'.
    :type categories: list[str]
    :param retention_policy: Required. the retention policy for the events in the log.
    :type retention_policy: ~monitor_client.models.RetentionPolicy
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'locations': {'required': True},
        'categories': {'required': True},
        'retention_policy': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'storage_account_id': {'key': 'properties.storageAccountId', 'type': 'str'},
        'service_bus_rule_id': {'key': 'properties.serviceBusRuleId', 'type': 'str'},
        'locations': {'key': 'properties.locations', 'type': '[str]'},
        'categories': {'key': 'properties.categories', 'type': '[str]'},
        'retention_policy': {'key': 'properties.retentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        *,
        location: str,
        locations: List[str],
        categories: List[str],
        retention_policy: "RetentionPolicy",
        tags: Optional[Dict[str, str]] = None,
        storage_account_id: Optional[str] = None,
        service_bus_rule_id: Optional[str] = None,
        **kwargs
    ):
        super(LogProfileResource, self).__init__(location=location, tags=tags, **kwargs)
        self.storage_account_id = storage_account_id
        self.service_bus_rule_id = service_bus_rule_id
        self.locations = locations
        self.categories = categories
        self.retention_policy = retention_policy


class LogProfileResourcePatch(msrest.serialization.Model):
    """The log profile resource for patch operations.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param storage_account_id: the resource id of the storage account to which you would like to
     send the Activity Log.
    :type storage_account_id: str
    :param service_bus_rule_id: The service bus rule ID of the service bus namespace in which you
     would like to have Event Hubs created for streaming the Activity Log. The rule ID is of the
     format: '{service bus resource ID}/authorizationrules/{key name}'.
    :type service_bus_rule_id: str
    :param locations: List of regions for which Activity Log events should be stored or streamed.
     It is a comma separated list of valid ARM locations including the 'global' location.
    :type locations: list[str]
    :param categories: the categories of the logs. These categories are created as is convenient to
     the user. Some values are: 'Write', 'Delete', and/or 'Action.'.
    :type categories: list[str]
    :param retention_policy: the retention policy for the events in the log.
    :type retention_policy: ~monitor_client.models.RetentionPolicy
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'storage_account_id': {'key': 'properties.storageAccountId', 'type': 'str'},
        'service_bus_rule_id': {'key': 'properties.serviceBusRuleId', 'type': 'str'},
        'locations': {'key': 'properties.locations', 'type': '[str]'},
        'categories': {'key': 'properties.categories', 'type': '[str]'},
        'retention_policy': {'key': 'properties.retentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        storage_account_id: Optional[str] = None,
        service_bus_rule_id: Optional[str] = None,
        locations: Optional[List[str]] = None,
        categories: Optional[List[str]] = None,
        retention_policy: Optional["RetentionPolicy"] = None,
        **kwargs
    ):
        super(LogProfileResourcePatch, self).__init__(**kwargs)
        self.tags = tags
        self.storage_account_id = storage_account_id
        self.service_bus_rule_id = service_bus_rule_id
        self.locations = locations
        self.categories = categories
        self.retention_policy = retention_policy


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class LogSearchRuleResource(Resource):
    """The Log Search Rule resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param description: The description of the Log Search rule.
    :type description: str
    :param enabled: The flag which indicates whether the Log Search rule is enabled. Value should
     be true or false. Possible values include: 'true', 'false'.
    :type enabled: str or ~monitor_client.models.Enabled
    :ivar last_updated_time: Last time the rule was updated in IS08601 format.
    :vartype last_updated_time: ~datetime.datetime
    :ivar provisioning_state: Provisioning state of the scheduled query rule. Possible values
     include: 'Succeeded', 'Deploying', 'Canceled', 'Failed'.
    :vartype provisioning_state: str or ~monitor_client.models.ProvisioningState
    :param source: Required. Data Source against which rule will Query Data.
    :type source: ~monitor_client.models.Source
    :param schedule: Schedule (Frequency, Time Window) for rule. Required for action type -
     AlertingAction.
    :type schedule: ~monitor_client.models.Schedule
    :param action: Required. Action needs to be taken on rule execution.
    :type action: ~monitor_client.models.Action
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'last_updated_time': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'source': {'required': True},
        'action': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'enabled': {'key': 'properties.enabled', 'type': 'str'},
        'last_updated_time': {'key': 'properties.lastUpdatedTime', 'type': 'iso-8601'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'source': {'key': 'properties.source', 'type': 'Source'},
        'schedule': {'key': 'properties.schedule', 'type': 'Schedule'},
        'action': {'key': 'properties.action', 'type': 'Action'},
    }

    def __init__(
        self,
        *,
        location: str,
        source: "Source",
        action: "Action",
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        enabled: Optional[Union[str, "Enabled"]] = None,
        schedule: Optional["Schedule"] = None,
        **kwargs
    ):
        super(LogSearchRuleResource, self).__init__(location=location, tags=tags, **kwargs)
        self.description = description
        self.enabled = enabled
        self.last_updated_time = None
        self.provisioning_state = None
        self.source = source
        self.schedule = schedule
        self.action = action


class LogSearchRuleResourceCollection(msrest.serialization.Model):
    """Represents a collection of Log Search rule resources.

    :param value: The values for the Log Search Rule resources.
    :type value: list[~monitor_client.models.LogSearchRuleResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LogSearchRuleResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["LogSearchRuleResource"]] = None,
        **kwargs
    ):
        super(LogSearchRuleResourceCollection, self).__init__(**kwargs)
        self.value = value


class LogSearchRuleResourcePatch(msrest.serialization.Model):
    """The log search rule resource for patch operations.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param enabled: The flag which indicates whether the Log Search rule is enabled. Value should
     be true or false. Possible values include: 'true', 'false'.
    :type enabled: str or ~monitor_client.models.Enabled
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'enabled': {'key': 'properties.enabled', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        enabled: Optional[Union[str, "Enabled"]] = None,
        **kwargs
    ):
        super(LogSearchRuleResourcePatch, self).__init__(**kwargs)
        self.tags = tags
        self.enabled = enabled


class LogSettings(msrest.serialization.Model):
    """Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular log.

    All required parameters must be populated in order to send to Azure.

    :param category: Name of a Diagnostic Log category for a resource type this setting is applied
     to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET
     diagnostic settings operation.
    :type category: str
    :param enabled: Required. a value indicating whether this log is enabled.
    :type enabled: bool
    :param retention_policy: the retention policy for this log.
    :type retention_policy: ~monitor_client.models.RetentionPolicy
    """

    _validation = {
        'enabled': {'required': True},
    }

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'retention_policy': {'key': 'retentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        *,
        enabled: bool,
        category: Optional[str] = None,
        retention_policy: Optional["RetentionPolicy"] = None,
        **kwargs
    ):
        super(LogSettings, self).__init__(**kwargs)
        self.category = category
        self.enabled = enabled
        self.retention_policy = retention_policy


class LogToMetricAction(Action):
    """Specify action need to be taken when rule type is converting log to metric.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. Specifies the action. Supported values - AlertingAction,
     LogToMetricAction.Constant filled by server.
    :type odata_type: str
    :param criteria: Required. Criteria of Metric.
    :type criteria: list[~monitor_client.models.Criteria]
    """

    _validation = {
        'odata_type': {'required': True},
        'criteria': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'criteria': {'key': 'criteria', 'type': '[Criteria]'},
    }

    def __init__(
        self,
        *,
        criteria: List["Criteria"],
        **kwargs
    ):
        super(LogToMetricAction, self).__init__(**kwargs)
        self.odata_type = 'Microsoft.WindowsAzure.Management.Monitoring.Alerts.Models.Microsoft.AppInsights.Nexus.DataContracts.Resources.ScheduledQueryRules.LogToMetricAction'
        self.criteria = criteria


class ManagementEventAggregationCondition(msrest.serialization.Model):
    """How the data that is collected should be combined over time.

    :param operator: the condition operator. Possible values include: 'GreaterThan',
     'GreaterThanOrEqual', 'LessThan', 'LessThanOrEqual'.
    :type operator: str or ~monitor_client.models.ConditionOperator
    :param threshold: The threshold value that activates the alert.
    :type threshold: float
    :param window_size: the period of time (in ISO 8601 duration format) that is used to monitor
     alert activity based on the threshold. If specified then it must be between 5 minutes and 1
     day.
    :type window_size: ~datetime.timedelta
    """

    _attribute_map = {
        'operator': {'key': 'operator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
        'window_size': {'key': 'windowSize', 'type': 'duration'},
    }

    def __init__(
        self,
        *,
        operator: Optional[Union[str, "ConditionOperator"]] = None,
        threshold: Optional[float] = None,
        window_size: Optional[datetime.timedelta] = None,
        **kwargs
    ):
        super(ManagementEventAggregationCondition, self).__init__(**kwargs)
        self.operator = operator
        self.threshold = threshold
        self.window_size = window_size


class ManagementEventRuleCondition(RuleCondition):
    """A management event rule condition.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of condition. This can be one of three types:
     ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition
     (based on the number of failures of a web test), and ThresholdRuleCondition (based on the
     threshold of a metric).Constant filled by server.
    :type odata_type: str
    :param data_source: the resource from which the rule collects its data. For this type
     dataSource will always be of type RuleMetricDataSource.
    :type data_source: ~monitor_client.models.RuleDataSource
    :param aggregation: How the data that is collected should be combined over time and when the
     alert is activated. Note that for management event alerts aggregation is optional – if it is
     not provided then any event will cause the alert to activate.
    :type aggregation: ~monitor_client.models.ManagementEventAggregationCondition
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'data_source': {'key': 'dataSource', 'type': 'RuleDataSource'},
        'aggregation': {'key': 'aggregation', 'type': 'ManagementEventAggregationCondition'},
    }

    def __init__(
        self,
        *,
        data_source: Optional["RuleDataSource"] = None,
        aggregation: Optional["ManagementEventAggregationCondition"] = None,
        **kwargs
    ):
        super(ManagementEventRuleCondition, self).__init__(data_source=data_source, **kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'
        self.aggregation = aggregation


class MetadataValue(msrest.serialization.Model):
    """Represents a metric metadata value.

    :param name: the name of the metadata.
    :type name: ~monitor_client.models.LocalizableString
    :param value: the value of the metadata.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'LocalizableString'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional["LocalizableString"] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(MetadataValue, self).__init__(**kwargs)
        self.name = name
        self.value = value


class Metric(msrest.serialization.Model):
    """The result data of a query.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. the metric Id.
    :type id: str
    :param type: Required. the resource type of the metric resource.
    :type type: str
    :param name: Required. the name and the display name of the metric, i.e. it is localizable
     string.
    :type name: ~monitor_client.models.LocalizableString
    :param unit: Required. the unit of the metric. Possible values include: 'Count', 'Bytes',
     'Seconds', 'CountPerSecond', 'BytesPerSecond', 'Percent', 'MilliSeconds', 'ByteSeconds',
     'Unspecified', 'Cores', 'MilliCores', 'NanoCores', 'BitsPerSecond'.
    :type unit: str or ~monitor_client.models.Unit
    :param timeseries: Required. the time series returned when a data query is performed.
    :type timeseries: list[~monitor_client.models.TimeSeriesElement]
    """

    _validation = {
        'id': {'required': True},
        'type': {'required': True},
        'name': {'required': True},
        'unit': {'required': True},
        'timeseries': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'LocalizableString'},
        'unit': {'key': 'unit', 'type': 'str'},
        'timeseries': {'key': 'timeseries', 'type': '[TimeSeriesElement]'},
    }

    def __init__(
        self,
        *,
        id: str,
        type: str,
        name: "LocalizableString",
        unit: Union[str, "Unit"],
        timeseries: List["TimeSeriesElement"],
        **kwargs
    ):
        super(Metric, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.name = name
        self.unit = unit
        self.timeseries = timeseries


class MetricAlertAction(msrest.serialization.Model):
    """An alert action.

    :param action_group_id: the id of the action group to use.
    :type action_group_id: str
    :param web_hook_properties: The properties of a webhook object.
    :type web_hook_properties: dict[str, str]
    """

    _attribute_map = {
        'action_group_id': {'key': 'actionGroupId', 'type': 'str'},
        'web_hook_properties': {'key': 'webHookProperties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        action_group_id: Optional[str] = None,
        web_hook_properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(MetricAlertAction, self).__init__(**kwargs)
        self.action_group_id = action_group_id
        self.web_hook_properties = web_hook_properties


class MetricAlertCriteria(msrest.serialization.Model):
    """The rule criteria that defines the conditions of the alert rule.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: MetricAlertMultipleResourceMultipleMetricCriteria, MetricAlertSingleResourceMultipleMetricCriteria.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param odata_type: Required. specifies the type of the alert criteria.Constant filled by
     server.  Possible values include:
     'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
    :type odata_type: str or ~monitor_client.models.Odatatype
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria': 'MetricAlertMultipleResourceMultipleMetricCriteria', 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria': 'MetricAlertSingleResourceMultipleMetricCriteria'}
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, object]] = None,
        **kwargs
    ):
        super(MetricAlertCriteria, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.odata_type = 'MetricAlertCriteria'


class MetricAlertMultipleResourceMultipleMetricCriteria(MetricAlertCriteria):
    """Specifies the metric alert criteria for multiple resource that has multiple metric criteria.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param odata_type: Required. specifies the type of the alert criteria.Constant filled by
     server.  Possible values include:
     'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
    :type odata_type: str or ~monitor_client.models.Odatatype
    :param all_of: the list of multiple metric criteria for this 'all of' operation.
    :type all_of: list[~monitor_client.models.MultiMetricCriteria]
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'all_of': {'key': 'allOf', 'type': '[MultiMetricCriteria]'},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, object]] = None,
        all_of: Optional[List["MultiMetricCriteria"]] = None,
        **kwargs
    ):
        super(MetricAlertMultipleResourceMultipleMetricCriteria, self).__init__(additional_properties=additional_properties, **kwargs)
        self.odata_type = 'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria'
        self.all_of = all_of


class Resource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        location: str,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = location
        self.tags = tags


class MetricAlertResource(Resource):
    """The metric alert resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param location: Required. Resource location.
    :type location: str
    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param description: Required. the description of the metric alert that will be included in the
     alert email.
    :type description: str
    :param severity: Required. Alert severity {0, 1, 2, 3, 4}.
    :type severity: int
    :param enabled: Required. the flag that indicates whether the metric alert is enabled.
    :type enabled: bool
    :param scopes: the list of resource id's that this metric alert is scoped to.
    :type scopes: list[str]
    :param evaluation_frequency: Required. how often the metric alert is evaluated represented in
     ISO 8601 duration format.
    :type evaluation_frequency: ~datetime.timedelta
    :param window_size: Required. the period of time (in ISO 8601 duration format) that is used to
     monitor alert activity based on the threshold.
    :type window_size: ~datetime.timedelta
    :param target_resource_type: the resource type of the target resource(s) on which the alert is
     created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
    :type target_resource_type: str
    :param target_resource_region: the region of the target resource(s) on which the alert is
     created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
    :type target_resource_region: str
    :param criteria: Required. defines the specific alert criteria information.
    :type criteria: ~monitor_client.models.MetricAlertCriteria
    :param auto_mitigate: the flag that indicates whether the alert should be auto resolved or not.
    :type auto_mitigate: bool
    :param actions: the array of actions that are performed when the alert rule becomes active, and
     when an alert condition is resolved.
    :type actions: list[~monitor_client.models.MetricAlertAction]
    :ivar last_updated_time: Last time the rule was updated in ISO8601 format.
    :vartype last_updated_time: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'location': {'required': True},
        'description': {'required': True},
        'severity': {'required': True},
        'enabled': {'required': True},
        'evaluation_frequency': {'required': True},
        'window_size': {'required': True},
        'criteria': {'required': True},
        'last_updated_time': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'severity': {'key': 'properties.severity', 'type': 'int'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'scopes': {'key': 'properties.scopes', 'type': '[str]'},
        'evaluation_frequency': {'key': 'properties.evaluationFrequency', 'type': 'duration'},
        'window_size': {'key': 'properties.windowSize', 'type': 'duration'},
        'target_resource_type': {'key': 'properties.targetResourceType', 'type': 'str'},
        'target_resource_region': {'key': 'properties.targetResourceRegion', 'type': 'str'},
        'criteria': {'key': 'properties.criteria', 'type': 'MetricAlertCriteria'},
        'auto_mitigate': {'key': 'properties.autoMitigate', 'type': 'bool'},
        'actions': {'key': 'properties.actions', 'type': '[MetricAlertAction]'},
        'last_updated_time': {'key': 'properties.lastUpdatedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        location: str,
        description: str,
        severity: int,
        enabled: bool,
        evaluation_frequency: datetime.timedelta,
        window_size: datetime.timedelta,
        criteria: "MetricAlertCriteria",
        tags: Optional[Dict[str, str]] = None,
        scopes: Optional[List[str]] = None,
        target_resource_type: Optional[str] = None,
        target_resource_region: Optional[str] = None,
        auto_mitigate: Optional[bool] = None,
        actions: Optional[List["MetricAlertAction"]] = None,
        **kwargs
    ):
        super(MetricAlertResource, self).__init__(location=location, tags=tags, **kwargs)
        self.description = description
        self.severity = severity
        self.enabled = enabled
        self.scopes = scopes
        self.evaluation_frequency = evaluation_frequency
        self.window_size = window_size
        self.target_resource_type = target_resource_type
        self.target_resource_region = target_resource_region
        self.criteria = criteria
        self.auto_mitigate = auto_mitigate
        self.actions = actions
        self.last_updated_time = None


class MetricAlertResourceCollection(msrest.serialization.Model):
    """Represents a collection of alert rule resources.

    :param value: the values for the alert rule resources.
    :type value: list[~monitor_client.models.MetricAlertResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MetricAlertResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["MetricAlertResource"]] = None,
        **kwargs
    ):
        super(MetricAlertResourceCollection, self).__init__(**kwargs)
        self.value = value


class MetricAlertResourcePatch(msrest.serialization.Model):
    """The metric alert resource for patch operations.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param tags: A set of tags. Resource tags.
    :type tags: dict[str, str]
    :param description: the description of the metric alert that will be included in the alert
     email.
    :type description: str
    :param severity: Alert severity {0, 1, 2, 3, 4}.
    :type severity: int
    :param enabled: the flag that indicates whether the metric alert is enabled.
    :type enabled: bool
    :param scopes: the list of resource id's that this metric alert is scoped to.
    :type scopes: list[str]
    :param evaluation_frequency: how often the metric alert is evaluated represented in ISO 8601
     duration format.
    :type evaluation_frequency: ~datetime.timedelta
    :param window_size: the period of time (in ISO 8601 duration format) that is used to monitor
     alert activity based on the threshold.
    :type window_size: ~datetime.timedelta
    :param target_resource_type: the resource type of the target resource(s) on which the alert is
     created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
    :type target_resource_type: str
    :param target_resource_region: the region of the target resource(s) on which the alert is
     created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
    :type target_resource_region: str
    :param criteria: defines the specific alert criteria information.
    :type criteria: ~monitor_client.models.MetricAlertCriteria
    :param auto_mitigate: the flag that indicates whether the alert should be auto resolved or not.
    :type auto_mitigate: bool
    :param actions: the array of actions that are performed when the alert rule becomes active, and
     when an alert condition is resolved.
    :type actions: list[~monitor_client.models.MetricAlertAction]
    :ivar last_updated_time: Last time the rule was updated in ISO8601 format.
    :vartype last_updated_time: ~datetime.datetime
    """

    _validation = {
        'last_updated_time': {'readonly': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'severity': {'key': 'properties.severity', 'type': 'int'},
        'enabled': {'key': 'properties.enabled', 'type': 'bool'},
        'scopes': {'key': 'properties.scopes', 'type': '[str]'},
        'evaluation_frequency': {'key': 'properties.evaluationFrequency', 'type': 'duration'},
        'window_size': {'key': 'properties.windowSize', 'type': 'duration'},
        'target_resource_type': {'key': 'properties.targetResourceType', 'type': 'str'},
        'target_resource_region': {'key': 'properties.targetResourceRegion', 'type': 'str'},
        'criteria': {'key': 'properties.criteria', 'type': 'MetricAlertCriteria'},
        'auto_mitigate': {'key': 'properties.autoMitigate', 'type': 'bool'},
        'actions': {'key': 'properties.actions', 'type': '[MetricAlertAction]'},
        'last_updated_time': {'key': 'properties.lastUpdatedTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        severity: Optional[int] = None,
        enabled: Optional[bool] = None,
        scopes: Optional[List[str]] = None,
        evaluation_frequency: Optional[datetime.timedelta] = None,
        window_size: Optional[datetime.timedelta] = None,
        target_resource_type: Optional[str] = None,
        target_resource_region: Optional[str] = None,
        criteria: Optional["MetricAlertCriteria"] = None,
        auto_mitigate: Optional[bool] = None,
        actions: Optional[List["MetricAlertAction"]] = None,
        **kwargs
    ):
        super(MetricAlertResourcePatch, self).__init__(**kwargs)
        self.tags = tags
        self.description = description
        self.severity = severity
        self.enabled = enabled
        self.scopes = scopes
        self.evaluation_frequency = evaluation_frequency
        self.window_size = window_size
        self.target_resource_type = target_resource_type
        self.target_resource_region = target_resource_region
        self.criteria = criteria
        self.auto_mitigate = auto_mitigate
        self.actions = actions
        self.last_updated_time = None


class MetricAlertSingleResourceMultipleMetricCriteria(MetricAlertCriteria):
    """Specifies the metric alert criteria for a single resource that has multiple metric criteria.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param odata_type: Required. specifies the type of the alert criteria.Constant filled by
     server.  Possible values include:
     'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria',
     'Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria'.
    :type odata_type: str or ~monitor_client.models.Odatatype
    :param all_of: The list of metric criteria for this 'all of' operation.
    :type all_of: list[~monitor_client.models.MetricCriteria]
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'all_of': {'key': 'allOf', 'type': '[MetricCriteria]'},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, object]] = None,
        all_of: Optional[List["MetricCriteria"]] = None,
        **kwargs
    ):
        super(MetricAlertSingleResourceMultipleMetricCriteria, self).__init__(additional_properties=additional_properties, **kwargs)
        self.odata_type = 'Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria'
        self.all_of = all_of


class MetricAlertStatus(msrest.serialization.Model):
    """An alert status.

    :param name: The status name.
    :type name: str
    :param id: The alert rule arm id.
    :type id: str
    :param type: The extended resource type name.
    :type type: str
    :param properties: The alert status properties of the metric alert status.
    :type properties: ~monitor_client.models.MetricAlertStatusProperties
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'MetricAlertStatusProperties'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,
        type: Optional[str] = None,
        properties: Optional["MetricAlertStatusProperties"] = None,
        **kwargs
    ):
        super(MetricAlertStatus, self).__init__(**kwargs)
        self.name = name
        self.id = id
        self.type = type
        self.properties = properties


class MetricAlertStatusCollection(msrest.serialization.Model):
    """Represents a collection of alert rule resources.

    :param value: the values for the alert rule resources.
    :type value: list[~monitor_client.models.MetricAlertStatus]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MetricAlertStatus]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["MetricAlertStatus"]] = None,
        **kwargs
    ):
        super(MetricAlertStatusCollection, self).__init__(**kwargs)
        self.value = value


class MetricAlertStatusProperties(msrest.serialization.Model):
    """An alert status properties.

    :param dimensions: An object describing the type of the dimensions.
    :type dimensions: dict[str, str]
    :param status: status value.
    :type status: str
    :param timestamp: UTC time when the status was checked.
    :type timestamp: ~datetime.datetime
    """

    _attribute_map = {
        'dimensions': {'key': 'dimensions', 'type': '{str}'},
        'status': {'key': 'status', 'type': 'str'},
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        dimensions: Optional[Dict[str, str]] = None,
        status: Optional[str] = None,
        timestamp: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(MetricAlertStatusProperties, self).__init__(**kwargs)
        self.dimensions = dimensions
        self.status = status
        self.timestamp = timestamp


class MetricAvailability(msrest.serialization.Model):
    """Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time grain.

    :param time_grain: the time grain specifies the aggregation interval for the metric. Expressed
     as a duration 'PT1M', 'P1D', etc.
    :type time_grain: ~datetime.timedelta
    :param retention: the retention period for the metric at the specified timegrain.  Expressed as
     a duration 'PT1M', 'P1D', etc.
    :type retention: ~datetime.timedelta
    """

    _attribute_map = {
        'time_grain': {'key': 'timeGrain', 'type': 'duration'},
        'retention': {'key': 'retention', 'type': 'duration'},
    }

    def __init__(
        self,
        *,
        time_grain: Optional[datetime.timedelta] = None,
        retention: Optional[datetime.timedelta] = None,
        **kwargs
    ):
        super(MetricAvailability, self).__init__(**kwargs)
        self.time_grain = time_grain
        self.retention = retention


class MetricBaselinesResponse(msrest.serialization.Model):
    """A list of metric baselines.

    :param value: The list of metric baselines.
    :type value: list[~monitor_client.models.SingleMetricBaseline]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[SingleMetricBaseline]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["SingleMetricBaseline"]] = None,
        **kwargs
    ):
        super(MetricBaselinesResponse, self).__init__(**kwargs)
        self.value = value


class MetricCriteria(MultiMetricCriteria):
    """Criterion to filter metrics.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param criterion_type: Required. Specifies the type of threshold criteria.Constant filled by
     server.  Possible values include: 'StaticThresholdCriterion', 'DynamicThresholdCriterion'.
    :type criterion_type: str or ~monitor_client.models.CriterionType
    :param name: Required. Name of the criteria.
    :type name: str
    :param metric_name: Required. Name of the metric.
    :type metric_name: str
    :param metric_namespace: Namespace of the metric.
    :type metric_namespace: str
    :param time_aggregation: Required. the criteria time aggregation types. Possible values
     include: 'None', 'Average', 'Count', 'Minimum', 'Maximum', 'Total'.
    :type time_aggregation: str or ~monitor_client.models.AggregationType
    :param dimensions: List of dimension conditions.
    :type dimensions: list[~monitor_client.models.MetricDimension]
    :param operator: Required. the criteria operator. Possible values include: 'Equals',
     'NotEquals', 'GreaterThan', 'GreaterThanOrEqual', 'LessThan', 'LessThanOrEqual', 'Include'.
    :type operator: str or ~monitor_client.models.Operator
    :param threshold: Required. the criteria threshold value that activates the alert.
    :type threshold: float
    """

    _validation = {
        'criterion_type': {'required': True},
        'name': {'required': True},
        'metric_name': {'required': True},
        'time_aggregation': {'required': True},
        'operator': {'required': True},
        'threshold': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'criterion_type': {'key': 'criterionType', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'metric_namespace': {'key': 'metricNamespace', 'type': 'str'},
        'time_aggregation': {'key': 'timeAggregation', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[MetricDimension]'},
        'operator': {'key': 'operator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        name: str,
        metric_name: str,
        time_aggregation: Union[str, "AggregationType"],
        operator: Union[str, "Operator"],
        threshold: float,
        additional_properties: Optional[Dict[str, object]] = None,
        metric_namespace: Optional[str] = None,
        dimensions: Optional[List["MetricDimension"]] = None,
        **kwargs
    ):
        super(MetricCriteria, self).__init__(additional_properties=additional_properties, name=name, metric_name=metric_name, metric_namespace=metric_namespace, time_aggregation=time_aggregation, dimensions=dimensions, **kwargs)
        self.criterion_type = 'StaticThresholdCriterion'
        self.operator = operator
        self.threshold = threshold


class MetricDefinition(msrest.serialization.Model):
    """Metric definition class specifies the metadata for a metric.

    :param is_dimension_required: Flag to indicate whether the dimension is required.
    :type is_dimension_required: bool
    :param resource_id: the resource identifier of the resource that emitted the metric.
    :type resource_id: str
    :param namespace: the namespace the metric belongs to.
    :type namespace: str
    :param name: the name and the display name of the metric, i.e. it is a localizable string.
    :type name: ~monitor_client.models.LocalizableString
    :param unit: the unit of the metric. Possible values include: 'Count', 'Bytes', 'Seconds',
     'CountPerSecond', 'BytesPerSecond', 'Percent', 'MilliSeconds', 'ByteSeconds', 'Unspecified',
     'Cores', 'MilliCores', 'NanoCores', 'BitsPerSecond'.
    :type unit: str or ~monitor_client.models.Unit
    :param primary_aggregation_type: the primary aggregation type value defining how to use the
     values for display. Possible values include: 'None', 'Average', 'Count', 'Minimum', 'Maximum',
     'Total'.
    :type primary_aggregation_type: str or ~monitor_client.models.AggregationType
    :param supported_aggregation_types: the collection of what aggregation types are supported.
    :type supported_aggregation_types: list[str or ~monitor_client.models.AggregationType]
    :param metric_availabilities: the collection of what aggregation intervals are available to be
     queried.
    :type metric_availabilities: list[~monitor_client.models.MetricAvailability]
    :param id: the resource identifier of the metric definition.
    :type id: str
    :param dimensions: the name and the display name of the dimension, i.e. it is a localizable
     string.
    :type dimensions: list[~monitor_client.models.LocalizableString]
    """

    _attribute_map = {
        'is_dimension_required': {'key': 'isDimensionRequired', 'type': 'bool'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'name': {'key': 'name', 'type': 'LocalizableString'},
        'unit': {'key': 'unit', 'type': 'str'},
        'primary_aggregation_type': {'key': 'primaryAggregationType', 'type': 'str'},
        'supported_aggregation_types': {'key': 'supportedAggregationTypes', 'type': '[str]'},
        'metric_availabilities': {'key': 'metricAvailabilities', 'type': '[MetricAvailability]'},
        'id': {'key': 'id', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[LocalizableString]'},
    }

    def __init__(
        self,
        *,
        is_dimension_required: Optional[bool] = None,
        resource_id: Optional[str] = None,
        namespace: Optional[str] = None,
        name: Optional["LocalizableString"] = None,
        unit: Optional[Union[str, "Unit"]] = None,
        primary_aggregation_type: Optional[Union[str, "AggregationType"]] = None,
        supported_aggregation_types: Optional[List[Union[str, "AggregationType"]]] = None,
        metric_availabilities: Optional[List["MetricAvailability"]] = None,
        id: Optional[str] = None,
        dimensions: Optional[List["LocalizableString"]] = None,
        **kwargs
    ):
        super(MetricDefinition, self).__init__(**kwargs)
        self.is_dimension_required = is_dimension_required
        self.resource_id = resource_id
        self.namespace = namespace
        self.name = name
        self.unit = unit
        self.primary_aggregation_type = primary_aggregation_type
        self.supported_aggregation_types = supported_aggregation_types
        self.metric_availabilities = metric_availabilities
        self.id = id
        self.dimensions = dimensions


class MetricDefinitionCollection(msrest.serialization.Model):
    """Represents collection of metric definitions.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. the values for the metric definitions.
    :type value: list[~monitor_client.models.MetricDefinition]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MetricDefinition]'},
    }

    def __init__(
        self,
        *,
        value: List["MetricDefinition"],
        **kwargs
    ):
        super(MetricDefinitionCollection, self).__init__(**kwargs)
        self.value = value


class MetricDimension(msrest.serialization.Model):
    """Specifies a metric dimension.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the dimension.
    :type name: str
    :param operator: Required. the dimension operator. Only 'Include' and 'Exclude' are supported.
    :type operator: str
    :param values: Required. list of dimension values.
    :type values: list[str]
    """

    _validation = {
        'name': {'required': True},
        'operator': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'operator': {'key': 'operator', 'type': 'str'},
        'values': {'key': 'values', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: str,
        operator: str,
        values: List[str],
        **kwargs
    ):
        super(MetricDimension, self).__init__(**kwargs)
        self.name = name
        self.operator = operator
        self.values = values


class MetricNamespace(msrest.serialization.Model):
    """Metric namespace class specifies the metadata for a metric namespace.

    :param id: The ID of the metricNamespace.
    :type id: str
    :param type: The type of the namespace.
    :type type: str
    :param name: The name of the namespace.
    :type name: str
    :param properties: Properties which include the fully qualified namespace name.
    :type properties: ~monitor_client.models.MetricNamespaceName
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'MetricNamespaceName'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        type: Optional[str] = None,
        name: Optional[str] = None,
        properties: Optional["MetricNamespaceName"] = None,
        **kwargs
    ):
        super(MetricNamespace, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.name = name
        self.properties = properties


class MetricNamespaceCollection(msrest.serialization.Model):
    """Represents collection of metric namespaces.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. The values for the metric namespaces.
    :type value: list[~monitor_client.models.MetricNamespace]
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[MetricNamespace]'},
    }

    def __init__(
        self,
        *,
        value: List["MetricNamespace"],
        **kwargs
    ):
        super(MetricNamespaceCollection, self).__init__(**kwargs)
        self.value = value


class MetricNamespaceName(msrest.serialization.Model):
    """The fully qualified metric namespace name.

    :param metric_namespace_name: The metric namespace name.
    :type metric_namespace_name: str
    """

    _attribute_map = {
        'metric_namespace_name': {'key': 'metricNamespaceName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        metric_namespace_name: Optional[str] = None,
        **kwargs
    ):
        super(MetricNamespaceName, self).__init__(**kwargs)
        self.metric_namespace_name = metric_namespace_name


class MetricSettings(msrest.serialization.Model):
    """Part of MultiTenantDiagnosticSettings. Specifies the settings for a particular metric.

    All required parameters must be populated in order to send to Azure.

    :param time_grain: the timegrain of the metric in ISO8601 format.
    :type time_grain: ~datetime.timedelta
    :param category: Name of a Diagnostic Metric category for a resource type this setting is
     applied to. To obtain the list of Diagnostic metric categories for a resource, first perform a
     GET diagnostic settings operation.
    :type category: str
    :param enabled: Required. a value indicating whether this category is enabled.
    :type enabled: bool
    :param retention_policy: the retention policy for this category.
    :type retention_policy: ~monitor_client.models.RetentionPolicy
    """

    _validation = {
        'enabled': {'required': True},
    }

    _attribute_map = {
        'time_grain': {'key': 'timeGrain', 'type': 'duration'},
        'category': {'key': 'category', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'retention_policy': {'key': 'retentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        *,
        enabled: bool,
        time_grain: Optional[datetime.timedelta] = None,
        category: Optional[str] = None,
        retention_policy: Optional["RetentionPolicy"] = None,
        **kwargs
    ):
        super(MetricSettings, self).__init__(**kwargs)
        self.time_grain = time_grain
        self.category = category
        self.enabled = enabled
        self.retention_policy = retention_policy


class MetricSingleDimension(msrest.serialization.Model):
    """The metric dimension name and value.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the dimension.
    :type name: str
    :param value: Required. Value of the dimension.
    :type value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        value: str,
        **kwargs
    ):
        super(MetricSingleDimension, self).__init__(**kwargs)
        self.name = name
        self.value = value


class MetricTrigger(msrest.serialization.Model):
    """The trigger that results in a scaling action.

    All required parameters must be populated in order to send to Azure.

    :param metric_name: Required. the name of the metric that defines what the rule monitors.
    :type metric_name: str
    :param metric_resource_uri: Required. the resource identifier of the resource the rule
     monitors.
    :type metric_resource_uri: str
    :param time_grain: Required. the granularity of metrics the rule monitors. Must be one of the
     predefined values returned from metric definitions for the metric. Must be between 12 hours and
     1 minute.
    :type time_grain: ~datetime.timedelta
    :param statistic: Required. the metric statistic type. How the metrics from multiple instances
     are combined. Possible values include: 'Average', 'Min', 'Max', 'Sum'.
    :type statistic: str or ~monitor_client.models.MetricStatisticType
    :param time_window: Required. the range of time in which instance data is collected. This value
     must be greater than the delay in metric collection, which can vary from resource-to-resource.
     Must be between 12 hours and 5 minutes.
    :type time_window: ~datetime.timedelta
    :param time_aggregation: Required. time aggregation type. How the data that is collected should
     be combined over time. The default value is Average. Possible values include: 'Average',
     'Minimum', 'Maximum', 'Total', 'Count', 'Last'.
    :type time_aggregation: str or ~monitor_client.models.TimeAggregationType
    :param operator: Required. the operator that is used to compare the metric data and the
     threshold. Possible values include: 'Equals', 'NotEquals', 'GreaterThan', 'GreaterThanOrEqual',
     'LessThan', 'LessThanOrEqual'.
    :type operator: str or ~monitor_client.models.ComparisonOperationType
    :param threshold: Required. the threshold of the metric that triggers the scale action.
    :type threshold: float
    """

    _validation = {
        'metric_name': {'required': True},
        'metric_resource_uri': {'required': True},
        'time_grain': {'required': True},
        'statistic': {'required': True},
        'time_window': {'required': True},
        'time_aggregation': {'required': True},
        'operator': {'required': True},
        'threshold': {'required': True},
    }

    _attribute_map = {
        'metric_name': {'key': 'metricName', 'type': 'str'},
        'metric_resource_uri': {'key': 'metricResourceUri', 'type': 'str'},
        'time_grain': {'key': 'timeGrain', 'type': 'duration'},
        'statistic': {'key': 'statistic', 'type': 'str'},
        'time_window': {'key': 'timeWindow', 'type': 'duration'},
        'time_aggregation': {'key': 'timeAggregation', 'type': 'str'},
        'operator': {'key': 'operator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        metric_name: str,
        metric_resource_uri: str,
        time_grain: datetime.timedelta,
        statistic: Union[str, "MetricStatisticType"],
        time_window: datetime.timedelta,
        time_aggregation: Union[str, "TimeAggregationType"],
        operator: Union[str, "ComparisonOperationType"],
        threshold: float,
        **kwargs
    ):
        super(MetricTrigger, self).__init__(**kwargs)
        self.metric_name = metric_name
        self.metric_resource_uri = metric_resource_uri
        self.time_grain = time_grain
        self.statistic = statistic
        self.time_window = time_window
        self.time_aggregation = time_aggregation
        self.operator = operator
        self.threshold = threshold


class MetricValue(msrest.serialization.Model):
    """Represents a metric value.

    All required parameters must be populated in order to send to Azure.

    :param time_stamp: Required. the timestamp for the metric value in ISO 8601 format.
    :type time_stamp: ~datetime.datetime
    :param average: the average value in the time range.
    :type average: float
    :param minimum: the least value in the time range.
    :type minimum: float
    :param maximum: the greatest value in the time range.
    :type maximum: float
    :param total: the sum of all of the values in the time range.
    :type total: float
    :param count: the number of samples in the time range. Can be used to determine the number of
     values that contributed to the average value.
    :type count: float
    """

    _validation = {
        'time_stamp': {'required': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'average': {'key': 'average', 'type': 'float'},
        'minimum': {'key': 'minimum', 'type': 'float'},
        'maximum': {'key': 'maximum', 'type': 'float'},
        'total': {'key': 'total', 'type': 'float'},
        'count': {'key': 'count', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        time_stamp: datetime.datetime,
        average: Optional[float] = None,
        minimum: Optional[float] = None,
        maximum: Optional[float] = None,
        total: Optional[float] = None,
        count: Optional[float] = None,
        **kwargs
    ):
        super(MetricValue, self).__init__(**kwargs)
        self.time_stamp = time_stamp
        self.average = average
        self.minimum = minimum
        self.maximum = maximum
        self.total = total
        self.count = count


class Operation(msrest.serialization.Model):
    """Microsoft Insights API operation definition.

    :param name: Operation name: {provider}/{resource}/{operation}.
    :type name: str
    :param display: Display metadata associated with the operation.
    :type display: ~monitor_client.models.OperationDisplay
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display': {'key': 'display', 'type': 'OperationDisplay'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        display: Optional["OperationDisplay"] = None,
        **kwargs
    ):
        super(Operation, self).__init__(**kwargs)
        self.name = name
        self.display = display


class OperationDisplay(msrest.serialization.Model):
    """Display metadata associated with the operation.

    :param provider: Service provider: Microsoft.Insights.
    :type provider: str
    :param resource: Resource on which the operation is performed: AlertRules, Autoscale, etc.
    :type resource: str
    :param operation: Operation type: Read, write, delete, etc.
    :type operation: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        provider: Optional[str] = None,
        resource: Optional[str] = None,
        operation: Optional[str] = None,
        **kwargs
    ):
        super(OperationDisplay, self).__init__(**kwargs)
        self.provider = provider
        self.resource = resource
        self.operation = operation


class OperationListResult(msrest.serialization.Model):
    """Result of the request to list Microsoft.Insights operations. It contains a list of operations and a URL link to get the next set of results.

    :param value: List of operations supported by the Microsoft.Insights provider.
    :type value: list[~monitor_client.models.Operation]
    :param next_link: URL to get the next set of operation list results if there are any.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Operation]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Operation"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(OperationListResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ProxyResource(msrest.serialization.Model):
    """An azure resource object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ProxyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None


class Recurrence(msrest.serialization.Model):
    """The repeating times at which this profile begins. This element is not used if the FixedDate element is used.

    All required parameters must be populated in order to send to Azure.

    :param frequency: Required. the recurrence frequency. How often the schedule profile should
     take effect. This value must be Week, meaning each week will have the same set of profiles. For
     example, to set a daily schedule, set **schedule** to every day of the week. The frequency
     property specifies that the schedule is repeated weekly. Possible values include: 'None',
     'Second', 'Minute', 'Hour', 'Day', 'Week', 'Month', 'Year'.
    :type frequency: str or ~monitor_client.models.RecurrenceFrequency
    :param schedule: Required. the scheduling constraints for when the profile begins.
    :type schedule: ~monitor_client.models.RecurrentSchedule
    """

    _validation = {
        'frequency': {'required': True},
        'schedule': {'required': True},
    }

    _attribute_map = {
        'frequency': {'key': 'frequency', 'type': 'str'},
        'schedule': {'key': 'schedule', 'type': 'RecurrentSchedule'},
    }

    def __init__(
        self,
        *,
        frequency: Union[str, "RecurrenceFrequency"],
        schedule: "RecurrentSchedule",
        **kwargs
    ):
        super(Recurrence, self).__init__(**kwargs)
        self.frequency = frequency
        self.schedule = schedule


class RecurrentSchedule(msrest.serialization.Model):
    """The scheduling constraints for when the profile begins.

    All required parameters must be populated in order to send to Azure.

    :param time_zone: Required. the timezone for the hours of the profile. Some examples of valid
     time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time,
     Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain
     Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard
     Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time,
     Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard
     Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time,
     Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina
     Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time,
     Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde
     Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W.
     Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European
     Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time,
     GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E.
     Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time,
     Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time,
     Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran
     Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius
     Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West
     Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time,
     Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard
     Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia
     Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W.
     Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time,
     Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard
     Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time,
     Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10,
     Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
     Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands
     Standard Time.
    :type time_zone: str
    :param days: Required. the collection of days that the profile takes effect on. Possible values
     are Sunday through Saturday.
    :type days: list[str]
    :param hours: Required. A collection of hours that the profile takes effect on. Values
     supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
    :type hours: list[int]
    :param minutes: Required. A collection of minutes at which the profile takes effect at.
    :type minutes: list[int]
    """

    _validation = {
        'time_zone': {'required': True},
        'days': {'required': True},
        'hours': {'required': True},
        'minutes': {'required': True},
    }

    _attribute_map = {
        'time_zone': {'key': 'timeZone', 'type': 'str'},
        'days': {'key': 'days', 'type': '[str]'},
        'hours': {'key': 'hours', 'type': '[int]'},
        'minutes': {'key': 'minutes', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        time_zone: str,
        days: List[str],
        hours: List[int],
        minutes: List[int],
        **kwargs
    ):
        super(RecurrentSchedule, self).__init__(**kwargs)
        self.time_zone = time_zone
        self.days = days
        self.hours = hours
        self.minutes = minutes


class Response(msrest.serialization.Model):
    """The response to a metrics query.

    All required parameters must be populated in order to send to Azure.

    :param cost: The integer value representing the cost of the query, for data case.
    :type cost: int
    :param timespan: Required. The timespan for which the data was retrieved. Its value consists of
     two datetimes concatenated, separated by '/'.  This may be adjusted in the future and returned
     back from what was originally requested.
    :type timespan: str
    :param interval: The interval (window size) for which the metric data was returned in.  This
     may be adjusted in the future and returned back from what was originally requested.  This is
     not present if a metadata request was made.
    :type interval: ~datetime.timedelta
    :param namespace: The namespace of the metrics been queried.
    :type namespace: str
    :param resourceregion: The region of the resource been queried for metrics.
    :type resourceregion: str
    :param value: Required. the value of the collection.
    :type value: list[~monitor_client.models.Metric]
    """

    _validation = {
        'cost': {'minimum': 0},
        'timespan': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'cost': {'key': 'cost', 'type': 'int'},
        'timespan': {'key': 'timespan', 'type': 'str'},
        'interval': {'key': 'interval', 'type': 'duration'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'resourceregion': {'key': 'resourceregion', 'type': 'str'},
        'value': {'key': 'value', 'type': '[Metric]'},
    }

    def __init__(
        self,
        *,
        timespan: str,
        value: List["Metric"],
        cost: Optional[int] = None,
        interval: Optional[datetime.timedelta] = None,
        namespace: Optional[str] = None,
        resourceregion: Optional[str] = None,
        **kwargs
    ):
        super(Response, self).__init__(**kwargs)
        self.cost = cost
        self.timespan = timespan
        self.interval = interval
        self.namespace = namespace
        self.resourceregion = resourceregion
        self.value = value


class ResponseWithError(msrest.serialization.Model):
    """An error response from the API.

    All required parameters must be populated in order to send to Azure.

    :param error: Required. Error information.
    :type error: ~monitor_client.models.Error
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'Error'},
    }

    def __init__(
        self,
        *,
        error: "Error",
        **kwargs
    ):
        super(ResponseWithError, self).__init__(**kwargs)
        self.error = error


class RetentionPolicy(msrest.serialization.Model):
    """Specifies the retention policy for the log.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. a value indicating whether the retention policy is enabled.
    :type enabled: bool
    :param days: Required. the number of days for the retention in days. A value of 0 will retain
     the events indefinitely.
    :type days: int
    """

    _validation = {
        'enabled': {'required': True},
        'days': {'required': True, 'minimum': 0},
    }

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'days': {'key': 'days', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        enabled: bool,
        days: int,
        **kwargs
    ):
        super(RetentionPolicy, self).__init__(**kwargs)
        self.enabled = enabled
        self.days = days


class RuleAction(msrest.serialization.Model):
    """The action that is performed when the alert rule becomes active, and when an alert condition is resolved.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: RuleEmailAction, RuleWebhookAction.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of the action. There are two types of actions:
     RuleEmailAction and RuleWebhookAction.Constant filled by server.
    :type odata_type: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'Microsoft.Azure.Management.Insights.Models.RuleEmailAction': 'RuleEmailAction', 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction': 'RuleWebhookAction'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RuleAction, self).__init__(**kwargs)
        self.odata_type = None


class RuleDataSource(msrest.serialization.Model):
    """The resource from which the rule collects its data.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: RuleManagementEventDataSource, RuleMetricDataSource.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of data source. There are two types of rule
     data sources: RuleMetricDataSource and RuleManagementEventDataSource.Constant filled by server.
    :type odata_type: str
    :param resource_uri: the resource identifier of the resource the rule monitors. **NOTE**\ :
     this property cannot be updated for an existing rule.
    :type resource_uri: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'resource_uri': {'key': 'resourceUri', 'type': 'str'},
    }

    _subtype_map = {
        'odata_type': {'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource': 'RuleManagementEventDataSource', 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource': 'RuleMetricDataSource'}
    }

    def __init__(
        self,
        *,
        resource_uri: Optional[str] = None,
        **kwargs
    ):
        super(RuleDataSource, self).__init__(**kwargs)
        self.odata_type = None
        self.resource_uri = resource_uri


class RuleEmailAction(RuleAction):
    """Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of the action. There are two types of actions:
     RuleEmailAction and RuleWebhookAction.Constant filled by server.
    :type odata_type: str
    :param send_to_service_owners: Whether the administrators (service and co-administrators) of
     the service should be notified when the alert is activated.
    :type send_to_service_owners: bool
    :param custom_emails: the list of administrator's custom email addresses to notify of the
     activation of the alert.
    :type custom_emails: list[str]
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'send_to_service_owners': {'key': 'sendToServiceOwners', 'type': 'bool'},
        'custom_emails': {'key': 'customEmails', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        send_to_service_owners: Optional[bool] = None,
        custom_emails: Optional[List[str]] = None,
        **kwargs
    ):
        super(RuleEmailAction, self).__init__(**kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'
        self.send_to_service_owners = send_to_service_owners
        self.custom_emails = custom_emails


class RuleManagementEventClaimsDataSource(msrest.serialization.Model):
    """The claims for a rule management event data source.

    :param email_address: the email address.
    :type email_address: str
    """

    _attribute_map = {
        'email_address': {'key': 'emailAddress', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        email_address: Optional[str] = None,
        **kwargs
    ):
        super(RuleManagementEventClaimsDataSource, self).__init__(**kwargs)
        self.email_address = email_address


class RuleManagementEventDataSource(RuleDataSource):
    """A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of data source. There are two types of rule
     data sources: RuleMetricDataSource and RuleManagementEventDataSource.Constant filled by server.
    :type odata_type: str
    :param resource_uri: the resource identifier of the resource the rule monitors. **NOTE**\ :
     this property cannot be updated for an existing rule.
    :type resource_uri: str
    :param event_name: the event name.
    :type event_name: str
    :param event_source: the event source.
    :type event_source: str
    :param level: the level.
    :type level: str
    :param operation_name: The name of the operation that should be checked for. If no name is
     provided, any operation will match.
    :type operation_name: str
    :param resource_group_name: the resource group name.
    :type resource_group_name: str
    :param resource_provider_name: the resource provider name.
    :type resource_provider_name: str
    :param status: The status of the operation that should be checked for. If no status is
     provided, any status will match.
    :type status: str
    :param sub_status: the substatus.
    :type sub_status: str
    :param claims: the claims.
    :type claims: ~monitor_client.models.RuleManagementEventClaimsDataSource
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'resource_uri': {'key': 'resourceUri', 'type': 'str'},
        'event_name': {'key': 'eventName', 'type': 'str'},
        'event_source': {'key': 'eventSource', 'type': 'str'},
        'level': {'key': 'level', 'type': 'str'},
        'operation_name': {'key': 'operationName', 'type': 'str'},
        'resource_group_name': {'key': 'resourceGroupName', 'type': 'str'},
        'resource_provider_name': {'key': 'resourceProviderName', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'sub_status': {'key': 'subStatus', 'type': 'str'},
        'claims': {'key': 'claims', 'type': 'RuleManagementEventClaimsDataSource'},
    }

    def __init__(
        self,
        *,
        resource_uri: Optional[str] = None,
        event_name: Optional[str] = None,
        event_source: Optional[str] = None,
        level: Optional[str] = None,
        operation_name: Optional[str] = None,
        resource_group_name: Optional[str] = None,
        resource_provider_name: Optional[str] = None,
        status: Optional[str] = None,
        sub_status: Optional[str] = None,
        claims: Optional["RuleManagementEventClaimsDataSource"] = None,
        **kwargs
    ):
        super(RuleManagementEventDataSource, self).__init__(resource_uri=resource_uri, **kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'
        self.event_name = event_name
        self.event_source = event_source
        self.level = level
        self.operation_name = operation_name
        self.resource_group_name = resource_group_name
        self.resource_provider_name = resource_provider_name
        self.status = status
        self.sub_status = sub_status
        self.claims = claims


class RuleMetricDataSource(RuleDataSource):
    """A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of data source. There are two types of rule
     data sources: RuleMetricDataSource and RuleManagementEventDataSource.Constant filled by server.
    :type odata_type: str
    :param resource_uri: the resource identifier of the resource the rule monitors. **NOTE**\ :
     this property cannot be updated for an existing rule.
    :type resource_uri: str
    :param metric_name: the name of the metric that defines what the rule monitors.
    :type metric_name: str
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'resource_uri': {'key': 'resourceUri', 'type': 'str'},
        'metric_name': {'key': 'metricName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        resource_uri: Optional[str] = None,
        metric_name: Optional[str] = None,
        **kwargs
    ):
        super(RuleMetricDataSource, self).__init__(resource_uri=resource_uri, **kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'
        self.metric_name = metric_name


class RuleWebhookAction(RuleAction):
    """Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of the action. There are two types of actions:
     RuleEmailAction and RuleWebhookAction.Constant filled by server.
    :type odata_type: str
    :param service_uri: the service uri to Post the notification when the alert activates or
     resolves.
    :type service_uri: str
    :param properties: the dictionary of custom properties to include with the post operation.
     These data are appended to the webhook payload.
    :type properties: dict[str, str]
    """

    _validation = {
        'odata_type': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'service_uri': {'key': 'serviceUri', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        service_uri: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(RuleWebhookAction, self).__init__(**kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'
        self.service_uri = service_uri
        self.properties = properties


class ScaleAction(msrest.serialization.Model):
    """The parameters for the scaling action.

    All required parameters must be populated in order to send to Azure.

    :param direction: Required. the scale direction. Whether the scaling action increases or
     decreases the number of instances. Possible values include: 'None', 'Increase', 'Decrease'.
    :type direction: str or ~monitor_client.models.ScaleDirection
    :param type: Required. the type of action that should occur when the scale rule fires. Possible
     values include: 'ChangeCount', 'PercentChangeCount', 'ExactCount'.
    :type type: str or ~monitor_client.models.ScaleType
    :param value: the number of instances that are involved in the scaling action. This value must
     be 1 or greater. The default value is 1.
    :type value: str
    :param cooldown: Required. the amount of time to wait since the last scaling action before this
     action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
    :type cooldown: ~datetime.timedelta
    """

    _validation = {
        'direction': {'required': True},
        'type': {'required': True},
        'cooldown': {'required': True},
    }

    _attribute_map = {
        'direction': {'key': 'direction', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'cooldown': {'key': 'cooldown', 'type': 'duration'},
    }

    def __init__(
        self,
        *,
        direction: Union[str, "ScaleDirection"],
        type: Union[str, "ScaleType"],
        cooldown: datetime.timedelta,
        value: Optional[str] = "1",
        **kwargs
    ):
        super(ScaleAction, self).__init__(**kwargs)
        self.direction = direction
        self.type = type
        self.value = value
        self.cooldown = cooldown


class ScaleCapacity(msrest.serialization.Model):
    """The number of instances that can be used during this profile.

    All required parameters must be populated in order to send to Azure.

    :param minimum: Required. the minimum number of instances for the resource.
    :type minimum: str
    :param maximum: Required. the maximum number of instances for the resource. The actual maximum
     number of instances is limited by the cores that are available in the subscription.
    :type maximum: str
    :param default: Required. the number of instances that will be set if metrics are not available
     for evaluation. The default is only used if the current instance count is lower than the
     default.
    :type default: str
    """

    _validation = {
        'minimum': {'required': True},
        'maximum': {'required': True},
        'default': {'required': True},
    }

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'str'},
        'maximum': {'key': 'maximum', 'type': 'str'},
        'default': {'key': 'default', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        minimum: str,
        maximum: str,
        default: str,
        **kwargs
    ):
        super(ScaleCapacity, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.default = default


class ScaleRule(msrest.serialization.Model):
    """A rule that provide the triggers and parameters for the scaling action.

    All required parameters must be populated in order to send to Azure.

    :param metric_trigger: Required. the trigger that results in a scaling action.
    :type metric_trigger: ~monitor_client.models.MetricTrigger
    :param scale_action: Required. the parameters for the scaling action.
    :type scale_action: ~monitor_client.models.ScaleAction
    """

    _validation = {
        'metric_trigger': {'required': True},
        'scale_action': {'required': True},
    }

    _attribute_map = {
        'metric_trigger': {'key': 'metricTrigger', 'type': 'MetricTrigger'},
        'scale_action': {'key': 'scaleAction', 'type': 'ScaleAction'},
    }

    def __init__(
        self,
        *,
        metric_trigger: "MetricTrigger",
        scale_action: "ScaleAction",
        **kwargs
    ):
        super(ScaleRule, self).__init__(**kwargs)
        self.metric_trigger = metric_trigger
        self.scale_action = scale_action


class Schedule(msrest.serialization.Model):
    """Defines how often to run the search and the time interval.

    All required parameters must be populated in order to send to Azure.

    :param frequency_in_minutes: Required. frequency (in minutes) at which rule condition should be
     evaluated.
    :type frequency_in_minutes: int
    :param time_window_in_minutes: Required. Time window for which data needs to be fetched for
     query (should be greater than or equal to frequencyInMinutes).
    :type time_window_in_minutes: int
    """

    _validation = {
        'frequency_in_minutes': {'required': True},
        'time_window_in_minutes': {'required': True},
    }

    _attribute_map = {
        'frequency_in_minutes': {'key': 'frequencyInMinutes', 'type': 'int'},
        'time_window_in_minutes': {'key': 'timeWindowInMinutes', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        frequency_in_minutes: int,
        time_window_in_minutes: int,
        **kwargs
    ):
        super(Schedule, self).__init__(**kwargs)
        self.frequency_in_minutes = frequency_in_minutes
        self.time_window_in_minutes = time_window_in_minutes


class SenderAuthorization(msrest.serialization.Model):
    """the authorization used by the user who has performed the operation that led to this event. This captures the RBAC properties of the event. These usually include the 'action', 'role' and the 'scope'.

    :param action: the permissible actions. For instance: microsoft.support/supporttickets/write.
    :type action: str
    :param role: the role of the user. For instance: Subscription Admin.
    :type role: str
    :param scope: the scope.
    :type scope: str
    """

    _attribute_map = {
        'action': {'key': 'action', 'type': 'str'},
        'role': {'key': 'role', 'type': 'str'},
        'scope': {'key': 'scope', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        action: Optional[str] = None,
        role: Optional[str] = None,
        scope: Optional[str] = None,
        **kwargs
    ):
        super(SenderAuthorization, self).__init__(**kwargs)
        self.action = action
        self.role = role
        self.scope = scope


class SingleBaseline(msrest.serialization.Model):
    """The baseline values for a single sensitivity value.

    All required parameters must be populated in order to send to Azure.

    :param sensitivity: Required. the sensitivity of the baseline. Possible values include: 'Low',
     'Medium', 'High'.
    :type sensitivity: str or ~monitor_client.models.BaselineSensitivity
    :param low_thresholds: Required. The low thresholds of the baseline.
    :type low_thresholds: list[float]
    :param high_thresholds: Required. The high thresholds of the baseline.
    :type high_thresholds: list[float]
    """

    _validation = {
        'sensitivity': {'required': True},
        'low_thresholds': {'required': True},
        'high_thresholds': {'required': True},
    }

    _attribute_map = {
        'sensitivity': {'key': 'sensitivity', 'type': 'str'},
        'low_thresholds': {'key': 'lowThresholds', 'type': '[float]'},
        'high_thresholds': {'key': 'highThresholds', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        sensitivity: Union[str, "BaselineSensitivity"],
        low_thresholds: List[float],
        high_thresholds: List[float],
        **kwargs
    ):
        super(SingleBaseline, self).__init__(**kwargs)
        self.sensitivity = sensitivity
        self.low_thresholds = low_thresholds
        self.high_thresholds = high_thresholds


class SingleMetricBaseline(msrest.serialization.Model):
    """The baseline results of a single metric.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. The metric baseline Id.
    :type id: str
    :param type: Required. The resource type of the metric baseline resource.
    :type type: str
    :param name: Required. The name of the metric for which the baselines were retrieved.
    :type name: str
    :param timespan: Required. The timespan for which the data was retrieved. Its value consists of
     two datetimes concatenated, separated by '/'.  This may be adjusted in the future and returned
     back from what was originally requested.
    :type timespan: str
    :param interval: Required. The interval (window size) for which the metric data was returned
     in.  This may be adjusted in the future and returned back from what was originally requested.
     This is not present if a metadata request was made.
    :type interval: ~datetime.timedelta
    :param namespace: The namespace of the metrics been queried.
    :type namespace: str
    :param baselines: Required. The baseline for each time series that was queried.
    :type baselines: list[~monitor_client.models.TimeSeriesBaseline]
    """

    _validation = {
        'id': {'required': True},
        'type': {'required': True},
        'name': {'required': True},
        'timespan': {'required': True},
        'interval': {'required': True},
        'baselines': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'timespan': {'key': 'properties.timespan', 'type': 'str'},
        'interval': {'key': 'properties.interval', 'type': 'duration'},
        'namespace': {'key': 'properties.namespace', 'type': 'str'},
        'baselines': {'key': 'properties.baselines', 'type': '[TimeSeriesBaseline]'},
    }

    def __init__(
        self,
        *,
        id: str,
        type: str,
        name: str,
        timespan: str,
        interval: datetime.timedelta,
        baselines: List["TimeSeriesBaseline"],
        namespace: Optional[str] = None,
        **kwargs
    ):
        super(SingleMetricBaseline, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.name = name
        self.timespan = timespan
        self.interval = interval
        self.namespace = namespace
        self.baselines = baselines


class SmsReceiver(msrest.serialization.Model):
    """An SMS receiver.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the SMS receiver. Names must be unique across all receivers
     within an action group.
    :type name: str
    :param country_code: Required. The country code of the SMS receiver.
    :type country_code: str
    :param phone_number: Required. The phone number of the SMS receiver.
    :type phone_number: str
    :ivar status: The status of the receiver. Possible values include: 'NotSpecified', 'Enabled',
     'Disabled'.
    :vartype status: str or ~monitor_client.models.ReceiverStatus
    """

    _validation = {
        'name': {'required': True},
        'country_code': {'required': True},
        'phone_number': {'required': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'country_code': {'key': 'countryCode', 'type': 'str'},
        'phone_number': {'key': 'phoneNumber', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        country_code: str,
        phone_number: str,
        **kwargs
    ):
        super(SmsReceiver, self).__init__(**kwargs)
        self.name = name
        self.country_code = country_code
        self.phone_number = phone_number
        self.status = None


class Source(msrest.serialization.Model):
    """Specifies the log search query.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param query: Log search query. Required for action type - AlertingAction.
    :type query: str
    :param authorized_resources: List of  Resource referred into query.
    :type authorized_resources: list[str]
    :param data_source_id: Required. The resource uri over which log search query is to be run.
    :type data_source_id: str
    :ivar query_type: Set value to 'ResultCount' . Default value: "ResultCount".
    :vartype query_type: str
    """

    _validation = {
        'data_source_id': {'required': True},
        'query_type': {'constant': True},
    }

    _attribute_map = {
        'query': {'key': 'query', 'type': 'str'},
        'authorized_resources': {'key': 'authorizedResources', 'type': '[str]'},
        'data_source_id': {'key': 'dataSourceId', 'type': 'str'},
        'query_type': {'key': 'queryType', 'type': 'str'},
    }

    query_type = "ResultCount"

    def __init__(
        self,
        *,
        data_source_id: str,
        query: Optional[str] = None,
        authorized_resources: Optional[List[str]] = None,
        **kwargs
    ):
        super(Source, self).__init__(**kwargs)
        self.query = query
        self.authorized_resources = authorized_resources
        self.data_source_id = data_source_id


class ThresholdRuleCondition(RuleCondition):
    """A rule condition based on a metric crossing a threshold.

    All required parameters must be populated in order to send to Azure.

    :param odata_type: Required. specifies the type of condition. This can be one of three types:
     ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition
     (based on the number of failures of a web test), and ThresholdRuleCondition (based on the
     threshold of a metric).Constant filled by server.
    :type odata_type: str
    :param data_source: the resource from which the rule collects its data. For this type
     dataSource will always be of type RuleMetricDataSource.
    :type data_source: ~monitor_client.models.RuleDataSource
    :param operator: Required. the operator used to compare the data and the threshold. Possible
     values include: 'GreaterThan', 'GreaterThanOrEqual', 'LessThan', 'LessThanOrEqual'.
    :type operator: str or ~monitor_client.models.ConditionOperator
    :param threshold: Required. the threshold value that activates the alert.
    :type threshold: float
    :param window_size: the period of time (in ISO 8601 duration format) that is used to monitor
     alert activity based on the threshold. If specified then it must be between 5 minutes and 1
     day.
    :type window_size: ~datetime.timedelta
    :param time_aggregation: the time aggregation operator. How the data that are collected should
     be combined over time. The default value is the PrimaryAggregationType of the Metric. Possible
     values include: 'Average', 'Minimum', 'Maximum', 'Total', 'Last'.
    :type time_aggregation: str or ~monitor_client.models.TimeAggregationOperator
    """

    _validation = {
        'odata_type': {'required': True},
        'operator': {'required': True},
        'threshold': {'required': True},
    }

    _attribute_map = {
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'data_source': {'key': 'dataSource', 'type': 'RuleDataSource'},
        'operator': {'key': 'operator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
        'window_size': {'key': 'windowSize', 'type': 'duration'},
        'time_aggregation': {'key': 'timeAggregation', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        operator: Union[str, "ConditionOperator"],
        threshold: float,
        data_source: Optional["RuleDataSource"] = None,
        window_size: Optional[datetime.timedelta] = None,
        time_aggregation: Optional[Union[str, "TimeAggregationOperator"]] = None,
        **kwargs
    ):
        super(ThresholdRuleCondition, self).__init__(data_source=data_source, **kwargs)
        self.odata_type = 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'
        self.operator = operator
        self.threshold = threshold
        self.window_size = window_size
        self.time_aggregation = time_aggregation


class TimeSeriesBaseline(msrest.serialization.Model):
    """The baseline values for a single time series.

    All required parameters must be populated in order to send to Azure.

    :param aggregation: Required. The aggregation type of the metric.
    :type aggregation: str
    :param dimensions: The dimensions of this time series.
    :type dimensions: list[~monitor_client.models.MetricSingleDimension]
    :param timestamps: Required. The list of timestamps of the baselines.
    :type timestamps: list[~datetime.datetime]
    :param data: Required. The baseline values for each sensitivity.
    :type data: list[~monitor_client.models.SingleBaseline]
    :param metadata: The baseline metadata values.
    :type metadata: list[~monitor_client.models.BaselineMetadata]
    """

    _validation = {
        'aggregation': {'required': True},
        'timestamps': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'aggregation': {'key': 'aggregation', 'type': 'str'},
        'dimensions': {'key': 'dimensions', 'type': '[MetricSingleDimension]'},
        'timestamps': {'key': 'timestamps', 'type': '[iso-8601]'},
        'data': {'key': 'data', 'type': '[SingleBaseline]'},
        'metadata': {'key': 'metadata', 'type': '[BaselineMetadata]'},
    }

    def __init__(
        self,
        *,
        aggregation: str,
        timestamps: List[datetime.datetime],
        data: List["SingleBaseline"],
        dimensions: Optional[List["MetricSingleDimension"]] = None,
        metadata: Optional[List["BaselineMetadata"]] = None,
        **kwargs
    ):
        super(TimeSeriesBaseline, self).__init__(**kwargs)
        self.aggregation = aggregation
        self.dimensions = dimensions
        self.timestamps = timestamps
        self.data = data
        self.metadata = metadata


class TimeSeriesElement(msrest.serialization.Model):
    """A time series result type. The discriminator value is always TimeSeries in this case.

    :param metadatavalues: the metadata values returned if $filter was specified in the call.
    :type metadatavalues: list[~monitor_client.models.MetadataValue]
    :param data: An array of data points representing the metric values.  This is only returned if
     a result type of data is specified.
    :type data: list[~monitor_client.models.MetricValue]
    """

    _attribute_map = {
        'metadatavalues': {'key': 'metadatavalues', 'type': '[MetadataValue]'},
        'data': {'key': 'data', 'type': '[MetricValue]'},
    }

    def __init__(
        self,
        *,
        metadatavalues: Optional[List["MetadataValue"]] = None,
        data: Optional[List["MetricValue"]] = None,
        **kwargs
    ):
        super(TimeSeriesElement, self).__init__(**kwargs)
        self.metadatavalues = metadatavalues
        self.data = data


class TimeSeriesInformation(msrest.serialization.Model):
    """The time series info needed for calculating the baseline.

    All required parameters must be populated in order to send to Azure.

    :param sensitivities: Required. the list of sensitivities for calculating the baseline.
    :type sensitivities: list[str]
    :param values: Required. The metric values to calculate the baseline.
    :type values: list[float]
    :param timestamps: the array of timestamps of the baselines.
    :type timestamps: list[~datetime.datetime]
    """

    _validation = {
        'sensitivities': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'sensitivities': {'key': 'sensitivities', 'type': '[str]'},
        'values': {'key': 'values', 'type': '[float]'},
        'timestamps': {'key': 'timestamps', 'type': '[iso-8601]'},
    }

    def __init__(
        self,
        *,
        sensitivities: List[str],
        values: List[float],
        timestamps: Optional[List[datetime.datetime]] = None,
        **kwargs
    ):
        super(TimeSeriesInformation, self).__init__(**kwargs)
        self.sensitivities = sensitivities
        self.values = values
        self.timestamps = timestamps


class TimeWindow(msrest.serialization.Model):
    """A specific date-time for the profile.

    All required parameters must be populated in order to send to Azure.

    :param time_zone: the timezone of the start and end times for the profile. Some examples of
     valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard
     Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time,
     Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central
     Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific
     Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time,
     Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western
     Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard
     Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo
     Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time,
     Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard
     Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central
     European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard
     Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time,
     E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time,
     Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time,
     Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran
     Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius
     Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West
     Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time,
     Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard
     Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia
     Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W.
     Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time,
     Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard
     Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time,
     Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10,
     Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
     Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands
     Standard Time.
    :type time_zone: str
    :param start: Required. the start time for the profile in ISO 8601 format.
    :type start: ~datetime.datetime
    :param end: Required. the end time for the profile in ISO 8601 format.
    :type end: ~datetime.datetime
    """

    _validation = {
        'start': {'required': True},
        'end': {'required': True},
    }

    _attribute_map = {
        'time_zone': {'key': 'timeZone', 'type': 'str'},
        'start': {'key': 'start', 'type': 'iso-8601'},
        'end': {'key': 'end', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        start: datetime.datetime,
        end: datetime.datetime,
        time_zone: Optional[str] = None,
        **kwargs
    ):
        super(TimeWindow, self).__init__(**kwargs)
        self.time_zone = time_zone
        self.start = start
        self.end = end


class TriggerCondition(msrest.serialization.Model):
    """The condition that results in the Log Search rule.

    All required parameters must be populated in order to send to Azure.

    :param threshold_operator: Required. Evaluation operation for rule - 'GreaterThan' or
     'LessThan. Possible values include: 'GreaterThan', 'LessThan', 'Equal'.
    :type threshold_operator: str or ~monitor_client.models.ConditionalOperator
    :param threshold: Required. Result or count threshold based on which rule should be triggered.
    :type threshold: float
    :param metric_trigger: Trigger condition for metric query rule.
    :type metric_trigger: ~monitor_client.models.LogMetricTrigger
    """

    _validation = {
        'threshold_operator': {'required': True},
        'threshold': {'required': True},
    }

    _attribute_map = {
        'threshold_operator': {'key': 'thresholdOperator', 'type': 'str'},
        'threshold': {'key': 'threshold', 'type': 'float'},
        'metric_trigger': {'key': 'metricTrigger', 'type': 'LogMetricTrigger'},
    }

    def __init__(
        self,
        *,
        threshold_operator: Union[str, "ConditionalOperator"],
        threshold: float,
        metric_trigger: Optional["LogMetricTrigger"] = None,
        **kwargs
    ):
        super(TriggerCondition, self).__init__(**kwargs)
        self.threshold_operator = threshold_operator
        self.threshold = threshold
        self.metric_trigger = metric_trigger


class VMInsightsOnboardingStatus(ProxyResource):
    """VM Insights onboarding status for a resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Azure resource Id.
    :vartype id: str
    :ivar name: Azure resource name.
    :vartype name: str
    :ivar type: Azure resource type.
    :vartype type: str
    :param resource_id: Azure Resource Manager identifier of the resource whose onboarding status
     is being represented.
    :type resource_id: str
    :param onboarding_status: The onboarding status for the resource. Note that, a higher level
     scope, e.g., resource group or subscription, is considered onboarded if at least one resource
     under it is onboarded. Possible values include: 'onboarded', 'notOnboarded', 'unknown'.
    :type onboarding_status: str or ~monitor_client.models.OnboardingStatus
    :param data_status: The status of VM Insights data from the resource. When reported as
     ``present`` the data array will contain information about the data containers to which data for
     the specified resource is being routed. Possible values include: 'present', 'notPresent'.
    :type data_status: str or ~monitor_client.models.DataStatus
    :param data: Containers that currently store VM Insights data for the specified resource.
    :type data: list[~monitor_client.models.DataContainer]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'resource_id': {'key': 'properties.resourceId', 'type': 'str'},
        'onboarding_status': {'key': 'properties.onboardingStatus', 'type': 'str'},
        'data_status': {'key': 'properties.dataStatus', 'type': 'str'},
        'data': {'key': 'properties.data', 'type': '[DataContainer]'},
    }

    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        onboarding_status: Optional[Union[str, "OnboardingStatus"]] = None,
        data_status: Optional[Union[str, "DataStatus"]] = None,
        data: Optional[List["DataContainer"]] = None,
        **kwargs
    ):
        super(VMInsightsOnboardingStatus, self).__init__(**kwargs)
        self.resource_id = resource_id
        self.onboarding_status = onboarding_status
        self.data_status = data_status
        self.data = data


class VoiceReceiver(msrest.serialization.Model):
    """A voice receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the voice receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param country_code: Required. The country code of the voice receiver.
    :type country_code: str
    :param phone_number: Required. The phone number of the voice receiver.
    :type phone_number: str
    """

    _validation = {
        'name': {'required': True},
        'country_code': {'required': True},
        'phone_number': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'country_code': {'key': 'countryCode', 'type': 'str'},
        'phone_number': {'key': 'phoneNumber', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        country_code: str,
        phone_number: str,
        **kwargs
    ):
        super(VoiceReceiver, self).__init__(**kwargs)
        self.name = name
        self.country_code = country_code
        self.phone_number = phone_number


class WebhookNotification(msrest.serialization.Model):
    """Webhook notification of an autoscale event.

    :param service_uri: the service address to receive the notification.
    :type service_uri: str
    :param properties: a property bag of settings. This value can be empty.
    :type properties: dict[str, str]
    """

    _attribute_map = {
        'service_uri': {'key': 'serviceUri', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        service_uri: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(WebhookNotification, self).__init__(**kwargs)
        self.service_uri = service_uri
        self.properties = properties


class WebhookReceiver(msrest.serialization.Model):
    """A webhook receiver.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the webhook receiver. Names must be unique across all
     receivers within an action group.
    :type name: str
    :param service_uri: Required. The URI where webhooks should be sent.
    :type service_uri: str
    :param use_common_alert_schema: Required. Indicates whether to use common alert schema.
    :type use_common_alert_schema: bool
    :param use_aad_auth: Indicates whether or not use AAD authentication.
    :type use_aad_auth: bool
    :param object_id: Indicates the webhook app object Id for aad auth.
    :type object_id: str
    :param identifier_uri: Indicates the identifier uri for aad auth.
    :type identifier_uri: str
    :param tenant_id: Indicates the tenant id for aad auth.
    :type tenant_id: str
    """

    _validation = {
        'name': {'required': True},
        'service_uri': {'required': True},
        'use_common_alert_schema': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'service_uri': {'key': 'serviceUri', 'type': 'str'},
        'use_common_alert_schema': {'key': 'useCommonAlertSchema', 'type': 'bool'},
        'use_aad_auth': {'key': 'useAadAuth', 'type': 'bool'},
        'object_id': {'key': 'objectId', 'type': 'str'},
        'identifier_uri': {'key': 'identifierUri', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        service_uri: str,
        use_common_alert_schema: bool,
        use_aad_auth: Optional[bool] = False,
        object_id: Optional[str] = None,
        identifier_uri: Optional[str] = None,
        tenant_id: Optional[str] = None,
        **kwargs
    ):
        super(WebhookReceiver, self).__init__(**kwargs)
        self.name = name
        self.service_uri = service_uri
        self.use_common_alert_schema = use_common_alert_schema
        self.use_aad_auth = use_aad_auth
        self.object_id = object_id
        self.identifier_uri = identifier_uri
        self.tenant_id = tenant_id


class WebtestLocationAvailabilityCriteria(msrest.serialization.Model):
    """Specifies the metric alert rule criteria for a web test resource.

    All required parameters must be populated in order to send to Azure.

    :param web_test_id: Required. The Application Insights web test Id.
    :type web_test_id: str
    :param component_id: Required. The Application Insights resource Id.
    :type component_id: str
    :param failed_location_count: Required. The number of failed locations.
    :type failed_location_count: float
    """

    _validation = {
        'web_test_id': {'required': True},
        'component_id': {'required': True},
        'failed_location_count': {'required': True},
    }

    _attribute_map = {
        'web_test_id': {'key': 'webTestId', 'type': 'str'},
        'component_id': {'key': 'componentId', 'type': 'str'},
        'failed_location_count': {'key': 'failedLocationCount', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        web_test_id: str,
        component_id: str,
        failed_location_count: float,
        **kwargs
    ):
        super(WebtestLocationAvailabilityCriteria, self).__init__(**kwargs)
        self.web_test_id = web_test_id
        self.component_id = component_id
        self.failed_location_count = failed_location_count


class WorkspaceInfo(msrest.serialization.Model):
    """Information about a Log Analytics Workspace.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Azure Resource Manager identifier of the Log Analytics Workspace.
    :type id: str
    :param location: Required. Location of the Log Analytics workspace.
    :type location: str
    :param customer_id: Required. Log Analytics workspace identifier.
    :type customer_id: str
    """

    _validation = {
        'id': {'required': True},
        'location': {'required': True},
        'customer_id': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'customer_id': {'key': 'properties.customerId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: str,
        location: str,
        customer_id: str,
        **kwargs
    ):
        super(WorkspaceInfo, self).__init__(**kwargs)
        self.id = id
        self.location = location
        self.customer_id = customer_id
